[
  {
    "chapter": "Docs > SvelteKit",
    "sections": [
      {
        "section": "Getting started",
        "blocks": [
          {
            "title": "Introduction > Before we begin",
            "content": "[!NOTE] If you're new to Svelte or SvelteKit we recommend checking out the [interactive tutorial](/tutorial/kit).\n\nIf you get stuck, reach out for help in the [Discord chatroom](https://svelte.dev/chat)."
          },
          {
            "title": "Introduction > What is SvelteKit?",
            "content": "SvelteKit is a framework for rapidly developing robust, performant web applications using Svelte. If you're coming from React, SvelteKit is similar to Next. If you're coming from Vue, SvelteKit is similar to Nuxt.To learn more about the kinds of applications you can build with SvelteKit, see the FAQ."
          },
          {
            "title": "Introduction > What is Svelte?",
            "content": "In short, Svelte is a way of writing user interface components — like a navigation bar, comment section, or contact form — that users see and interact with in their browsers. The Svelte compiler converts your components to JavaScript that can be run to render the HTML for the page and to CSS that styles the page. You don't need to know Svelte to understand the rest of this guide, but it will help. If you'd like to learn more, check out the Svelte tutorial."
          },
          {
            "title": "Introduction > SvelteKit vs Svelte",
            "content": "Svelte renders UI components. You can compose these components and render an entire page with just Svelte, but you need more than just Svelte to write an entire app.SvelteKit helps you build web apps while following modern best practices and providing solutions to common development challenges. It offers everything from basic functionalities — like a router that updates your UI when a link is clicked — to more advanced capabilities. Its extensive list of features includes build optimizations to load only the minimal required code; offline support; preloading pages before user navigation; configurable rendering to handle different parts of your app on the server via SSR, in the browser through client-side rendering, or at build-time with prerendering; image optimization; and much more. Building an app with all the modern best practices is fiendishly complicated, but SvelteKit does all the boring stuff for you so that you can get on with the creative part.It reflects changes to your code in the browser instantly to provide a lightning-fast and feature-rich development experience by leveraging Vite with a Svelte plugin to do Hot Module Replacement (HMR)."
          },
          {
            "title": "Creating a project",
            "content": "The easiest way to start building a SvelteKit app is to run npx sv create:npx sv create my-app\ncd my-app\nnpm install\nnpm run devThe first command will scaffold a new project in the my-app directory asking you if you'd like to set up some basic tooling such as TypeScript. See integrations for pointers on setting up additional tooling. The subsequent commands will then install its dependencies and start a server on localhost:5173.There are two basic concepts:undefined\nTry editing the files to get a feel for how everything works."
          },
          {
            "title": "Creating a project > Editor setup",
            "content": "We recommend using Visual Studio Code (aka VS Code) with the Svelte extension, but support also exists for numerous other editors."
          },
          {
            "title": "Project structure",
            "content": "A typical SvelteKit project looks like this:my-project/\n├ src/\n│ ├ lib/\n│ │ ├ server/\n│ │ │ └ [your server-only lib files]\n│ │ └ [your lib files]\n│ ├ params/\n│ │ └ [your param matchers]\n│ ├ routes/\n│ │ └ [your routes]\n│ ├ app.html\n│ ├ error.html\n│ ├ hooks.client.js\n│ ├ hooks.server.js\n│ └ service-worker.js\n├ static/\n│ └ [your static assets]\n├ tests/\n│ └ [your tests]\n├ package.json\n├ svelte.config.js\n├ tsconfig.json\n└ vite.config.jsYou'll also find common files like .gitignore and .npmrc (and .prettierrc and eslint.config.js and so on, if you chose those options when running npx sv create)."
          },
          {
            "title": "Project structure > Project files > src",
            "content": "The src directory contains the meat of your project. Everything except src/routes and src/app.html is optional.undefined\n(Whether the project contains .js or .ts files depends on whether you opt to use TypeScript when you create your project. You can switch between JavaScript and TypeScript in the documentation using the toggle at the bottom of this page.)If you added Vitest when you set up your project, your unit tests will live in the src directory with a .test.js extension."
          },
          {
            "title": "Project structure > Project files > static",
            "content": "Any static assets that should be served as-is, like robots.txt or favicon.png, go in here."
          },
          {
            "title": "Project structure > Project files > tests",
            "content": "If you added Playwright for browser testing when you set up your project, the tests will live in this directory."
          },
          {
            "title": "Project structure > Project files > package.json",
            "content": "Your package.json file must include @sveltejs/kit, svelte and vite as devDependencies.When you create a project with npx sv create, you'll also notice that package.json includes &quot;type&quot;: &quot;module&quot;. This means that .js files are interpreted as native JavaScript modules with import and export keywords. Legacy CommonJS files need a .cjs file extension."
          },
          {
            "title": "Project structure > Project files > svelte.config.js",
            "content": "This file contains your Svelte and SvelteKit configuration."
          },
          {
            "title": "Project structure > Project files > tsconfig.json",
            "content": "This file (or jsconfig.json, if you prefer type-checked .js files over .ts files) configures TypeScript, if you added typechecking during npx sv create. Since SvelteKit relies on certain configuration being set a specific way, it generates its own .svelte-kit/tsconfig.json file which your own config extends."
          },
          {
            "title": "Project structure > Project files > vite.config.js",
            "content": "A SvelteKit project is really just a Vite project that uses the `@sveltejs/kit/vite` plugin, along with any other Vite configuration."
          },
          {
            "title": "Project structure > Other files > .svelte-kit",
            "content": "As you develop and build your project, SvelteKit will generate files in a .svelte-kit directory (configurable as `outDir`). You can ignore its contents, and delete them at any time (they will be regenerated when you next dev or build)."
          },
          {
            "title": "Web standards",
            "content": "Throughout this documentation, you'll see references to the standard Web APIs that SvelteKit builds on top of. Rather than reinventing the wheel, we use the platform, which means your existing web development skills are applicable to SvelteKit. Conversely, time spent learning SvelteKit will help you be a better web developer elsewhere.These APIs are available in all modern browsers and in many non-browser environments like Cloudflare Workers, Deno, and Vercel Functions. During development, and in adapters for Node-based environments (including AWS Lambda), they're made available via polyfills where necessary (for now, that is — Node is rapidly adding support for more web standards).In particular, you'll get comfortable with the following:"
          },
          {
            "title": "Web standards > Fetch APIs",
            "content": "SvelteKit uses `fetch` for getting data from the network. It's available in hooks and server routes as well as in the browser.[!NOTE] A special version of `fetch` is available in [`load`](load) functions, [server hooks](hooks#Server-hooks) and [API routes](routing#server) for invoking endpoints directly during server-side rendering, without making an HTTP call, while preserving credentials. (To make credentialled fetches in server-side code outside `load`, you must explicitly pass `cookie` and/or `authorization` headers.) It also allows you to make relative requests, whereas server-side `fetch` normally requires a fully qualified URL.\nBesides fetch itself, the Fetch API includes the following interfaces:"
          },
          {
            "title": "Web standards > Fetch APIs > Request",
            "content": "An instance of `Request` is accessible in hooks and server routes as event.request. It contains useful methods like request.json() and request.formData() for getting data that was posted to an endpoint."
          },
          {
            "title": "Web standards > Fetch APIs > Response",
            "content": "An instance of `Response` is returned from await fetch(...) and handlers in +server.js files. Fundamentally, a SvelteKit app is a machine for turning a Request into a Response."
          },
          {
            "title": "Web standards > Fetch APIs > Headers",
            "content": "The `Headers` interface allows you to read incoming request.headers and set outgoing response.headers. For example, you can get the request.headers as shown below, and use the `json` convenience function to send modified response.headers: \n \nimport { json } from '@sveltejs/kit';\n\n/** @type {import('./$types').RequestHandler} */\nexport function GET({ request }) {\n\t// log all headers\n\tconsole.log(...request.headers);\n\n\t// create a JSON Response using a header we received\n\treturn json({\n\t\t// retrieve a specific header\n\t\tuserAgent: request.headers.get('user-agent')\n\t}, {\n\t\t// set a header on the response\n\t\theaders: { 'x-custom-header': 'potato' }\n\t});\n}"
          },
          {
            "title": "Web standards > FormData",
            "content": "When dealing with HTML native form submissions you'll be working with `FormData` objects. \n \nimport { json } from '@sveltejs/kit';\n\n/** @type {import('./$types').RequestHandler} */\nexport async function POST(event) {\n\tconst body = await event.request.formData();\n\n\t// log all fields\n\tconsole.log([...body]);\n\n\treturn json({\n\t\t// get a specific field's value\n\t\tname: body.get('name') ?? 'world'\n\t});\n}"
          },
          {
            "title": "Web standards > Stream APIs",
            "content": "Most of the time, your endpoints will return complete data, as in the userAgent example above. Sometimes, you may need to return a response that's too large to fit in memory in one go, or is delivered in chunks, and for this the platform provides streams — ReadableStream, WritableStream and TransformStream."
          },
          {
            "title": "Web standards > URL APIs",
            "content": "URLs are represented by the `URL` interface, which includes useful properties like origin and pathname (and, in the browser, hash). This interface shows up in various places — event.url in hooks and server routes, `$page.url` in pages, from and to in `beforeNavigate` and `afterNavigate` and so on."
          },
          {
            "title": "Web standards > URL APIs > URLSearchParams",
            "content": "Wherever you encounter a URL, you can access query parameters via url.searchParams, which is an instance of `URLSearchParams`:const foo = url.searchParams.get('foo');"
          },
          {
            "title": "Web standards > Web Crypto",
            "content": "The Web Crypto API is made available via the crypto global. It's used internally for Content Security Policy headers, but you can also use it for things like generating UUIDs:const uuid = crypto.randomUUID();"
          }
        ]
      },
      {
        "section": "Core concepts",
        "blocks": [
          {
            "title": "Routing",
            "content": "At the heart of SvelteKit is a filesystem-based router. The routes of your app — i.e. the URL paths that users can access — are defined by the directories in your codebase:undefined\n[!NOTE] You can change `src/routes` to a different directory by editing the [project config](configuration).\nEach route directory contains one or more route files, which can be identified by their + prefix.We'll introduce these files in a moment in more detail, but here are a few simple rules to help you remember how SvelteKit's routing works:undefined"
          },
          {
            "title": "Routing > +page > +page.svelte",
            "content": "A +page.svelte component defines a page of your app. By default, pages are rendered both on the server (SSR) for the initial request and in the browser (CSR) for subsequent navigation.<!--- file: src/routes/+page.svelte --->\n<h1>Hello and welcome to my site!</h1>\n<a href=\"/about\">About my site</a><!--- file: src/routes/about/+page.svelte --->\n<h1>About this site</h1>\n<p>TODO...</p>\n<a href=\"/\">Home</a><!--- file: src/routes/blog/[slug]/+page.svelte --->\n<script>\n\t/** @type {import('./$types').PageData} */\n\texport let data;\n</script>\n\n<h1>{data.title}</h1>\n<div>{@html data.content}</div>[!NOTE] Note that SvelteKit uses `<a>` elements to navigate between routes, rather than a framework-specific `<Link>` component."
          },
          {
            "title": "Routing > +page > +page.js",
            "content": "Often, a page will need to load some data before it can be rendered. For this, we add a +page.js module that exports a load function: \nimport { error } from '@sveltejs/kit';\n\n/** @type {import('./$types').PageLoad} */\nexport function load({ params }) {\n\tif (params.slug === 'hello-world') {\n\t\treturn {\n\t\t\ttitle: 'Hello world!',\n\t\t\tcontent: 'Welcome to our blog. Lorem ipsum dolor sit amet...'\n\t\t};\n\t}\n\n\terror(404, 'Not found');\n}This function runs alongside +page.svelte, which means it runs on the server during server-side rendering and in the browser during client-side navigation. See `load` for full details of the API.As well as load, +page.js can export values that configure the page's behaviour:undefined\nYou can find more information about these in page options."
          },
          {
            "title": "Routing > +page > +page.server.js",
            "content": "If your load function can only run on the server — for example, if it needs to fetch data from a database or you need to access private environment variables like API keys — then you can rename +page.js to +page.server.js and change the PageLoad type to PageServerLoad.import { error } from '@sveltejs/kit';\n\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ params }) {\n\tconst post = await getPostFromDatabase(params.slug);\n\n\tif (post) {\n\t\treturn post;\n\t}\n\n\terror(404, 'Not found');\n}During client-side navigation, SvelteKit will load this data from the server, which means that the returned value must be serializable using devalue. See `load` for full details of the API.Like +page.js, +page.server.js can export page options — prerender, ssr and csr.A +page.server.js file can also export actions. If load lets you read data from the server, actions let you write data to the server using the <form> element. To learn how to use them, see the form actions section."
          },
          {
            "title": "Routing > +error",
            "content": "If an error occurs during load, SvelteKit will render a default error page. You can customise this error page on a per-route basis by adding an +error.svelte file:<!--- file: src/routes/blog/[slug]/+error.svelte --->\n<script>\n\timport { page } from '$app/stores';\n</script>\n\n<h1>{$page.status}: {$page.error.message}</h1>SvelteKit will 'walk up the tree' looking for the closest error boundary — if the file above didn't exist it would try src/routes/blog/+error.svelte and then src/routes/+error.svelte before rendering the default error page. If that fails (or if the error was thrown from the load function of the root +layout, which sits 'above' the root +error), SvelteKit will bail out and render a static fallback error page, which you can customise by creating a src/error.html file.If the error occurs inside a load function in +layout(.server).js, the closest error boundary in the tree is an +error.svelte file above that layout (not next to it).If no route can be found (404), src/routes/+error.svelte (or the default error page, if that file does not exist) will be used.[!NOTE] `+error.svelte` is _not_ used when an error occurs inside [`handle`](hooks#Server-hooks-handle) or a [+server.js](#server) request handler.\nYou can read more about error handling here."
          },
          {
            "title": "Routing > +layout",
            "content": "So far, we've treated pages as entirely standalone components — upon navigation, the existing +page.svelte component will be destroyed, and a new one will take its place.But in many apps, there are elements that should be visible on every page, such as top-level navigation or a footer. Instead of repeating them in every +page.svelte, we can put them in layouts."
          },
          {
            "title": "Routing > +layout > +layout.svelte",
            "content": "To create a layout that applies to every page, make a file called src/routes/+layout.svelte. The default layout (the one that SvelteKit uses if you don't bring your own) looks like this...<slot></slot>...but we can add whatever markup, styles and behaviour we want. The only requirement is that the component includes a <slot> for the page content. For example, let's add a nav bar: \n<nav>\n\t<a href=\"/\">Home</a>\n\t<a href=\"/about\">About</a>\n\t<a href=\"/settings\">Settings</a>\n</nav>\n\n<slot></slot>If we create pages for /, /about and /settings... \n<h1>Home</h1> \n<h1>About</h1> \n<h1>Settings</h1>...the nav will always be visible, and clicking between the three pages will only result in the <h1> being replaced.Layouts can be nested. Suppose we don't just have a single /settings page, but instead have nested pages like /settings/profile and /settings/notifications with a shared submenu (for a real-life example, see github.com/settings).We can create a layout that only applies to pages below /settings (while inheriting the root layout with the top-level nav):<!--- file: src/routes/settings/+layout.svelte --->\n<script>\n\t/** @type {import('./$types').LayoutData} */\n\texport let data;\n</script>\n\n<h1>Settings</h1>\n\n<div class=\"submenu\">\n\t{#each data.sections as section}\n\t\t<a href=\"/settings/{section.slug}\">{section.title}</a>\n\t{/each}\n</div>\n\n<slot></slot>You can see how data is populated by looking at the +layout.js example in the next section just below.By default, each layout inherits the layout above it. Sometimes that isn't what you want - in this case, advanced layouts can help you."
          },
          {
            "title": "Routing > +layout > +layout.js",
            "content": "Just like +page.svelte loading data from +page.js, your +layout.svelte component can get data from a `load` function in +layout.js. \n/** @type {import('./$types').LayoutLoad} */\nexport function load() {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}If a +layout.js exports page options — prerender, ssr and csr — they will be used as defaults for child pages.Data returned from a layout's load function is also available to all its child pages:<!--- file: src/routes/settings/profile/+page.svelte --->\n<script>\n\t/** @type {import('./$types').PageData} */\n\texport let data;\n\n\tconsole.log(data.sections); // [{ slug: 'profile', title: 'Profile' }, ...]\n</script>[!NOTE] Often, layout data is unchanged when navigating between pages. SvelteKit will intelligently rerun [`load`](load) functions when necessary."
          },
          {
            "title": "Routing > +layout > +layout.server.js",
            "content": "To run your layout's load function on the server, move it to +layout.server.js, and change the LayoutLoad type to LayoutServerLoad.Like +layout.js, +layout.server.js can export page options — prerender, ssr and csr."
          },
          {
            "title": "Routing > +server",
            "content": "As well as pages, you can define routes with a +server.js file (sometimes referred to as an 'API route' or an 'endpoint'), which gives you full control over the response. Your +server.js file exports functions corresponding to HTTP verbs like GET, POST, PATCH, PUT, DELETE, OPTIONS, and HEAD that take a RequestEvent argument and return a `Response` object.For example we could create an /api/random-number route with a GET handler: \nimport { error } from '@sveltejs/kit';\n\n/** @type {import('./$types').RequestHandler} */\nexport function GET({ url }) {\n\tconst min = Number(url.searchParams.get('min') ?? '0');\n\tconst max = Number(url.searchParams.get('max') ?? '1');\n\n\tconst d = max - min;\n\n\tif (isNaN(d) || d < 0) {\n\t\terror(400, 'min and max must be numbers, and min must be less than max');\n\t}\n\n\tconst random = min + Math.random() * d;\n\n\treturn new Response(String(random));\n}The first argument to Response can be a `ReadableStream`, making it possible to stream large amounts of data or create server-sent events (unless deploying to platforms that buffer responses, like AWS Lambda).You can use the `error`, `redirect` and `json` methods from @sveltejs/kit for convenience (but you don't have to).If an error is thrown (either error(...) or an unexpected error), the response will be a JSON representation of the error or a fallback error page — which can be customised via src/error.html — depending on the Accept header. The `+error.svelte` component will not be rendered in this case. You can read more about error handling here.[!NOTE] When creating an `OPTIONS` handler, note that Vite will inject `Access-Control-Allow-Origin` and `Access-Control-Allow-Methods` headers — these will not be present in production unless you add them."
          },
          {
            "title": "Routing > +server > Receiving data",
            "content": "By exporting POST/PUT/PATCH/DELETE/OPTIONS/HEAD handlers, +server.js files can be used to create a complete API:<!--- file: src/routes/add/+page.svelte --->\n<script>\n\tlet a = 0;\n\tlet b = 0;\n\tlet total = 0;\n\n\tasync function add() {\n\t\tconst response = await fetch('/api/add', {\n\t\t\tmethod: 'POST',\n\t\t\tbody: JSON.stringify({ a, b }),\n\t\t\theaders: {\n\t\t\t\t'content-type': 'application/json'\n\t\t\t}\n\t\t});\n\n\t\ttotal = await response.json();\n\t}\n</script>\n\n<input type=\"number\" bind:value={a}> +\n<input type=\"number\" bind:value={b}> =\n{total}\n\n<button on:click={add}>Calculate</button> \nimport { json } from '@sveltejs/kit';\n\n/** @type {import('./$types').RequestHandler} */\nexport async function POST({ request }) {\n\tconst { a, b } = await request.json();\n\treturn json(a + b);\n}[!NOTE] In general, [form actions](form-actions) are a better way to submit data from the browser to the server.\n[!NOTE] If a `GET` handler is exported, a `HEAD` request will return the `content-length` of the `GET` handler's response body."
          },
          {
            "title": "Routing > +server > Fallback method handler",
            "content": "Exporting the fallback handler will match any unhandled request methods, including methods like MOVE which have no dedicated export from +server.js. \n \nimport { json, text } from '@sveltejs/kit';\n\nexport async function POST({ request }) {\n\tconst { a, b } = await request.json();\n\treturn json(a + b);\n}\n\n// This handler will respond to PUT, PATCH, DELETE, etc.\n/** @type {import('./$types').RequestHandler} */\nexport async function fallback({ request }) {\n\treturn text(`I caught your ${request.method} request!`);\n}[!NOTE] For `HEAD` requests, the `GET` handler takes precedence over the `fallback` handler."
          },
          {
            "title": "Routing > +server > Content negotiation",
            "content": "+server.js files can be placed in the same directory as +page files, allowing the same route to be either a page or an API endpoint. To determine which, SvelteKit applies the following rules:undefined"
          },
          {
            "title": "Routing > $types",
            "content": "Throughout the examples above, we've been importing types from a $types.d.ts file. This is a file SvelteKit creates for you in a hidden directory if you're using TypeScript (or JavaScript with JSDoc type annotations) to give you type safety when working with your root files.For example, annotating export let data with PageData (or LayoutData, for a +layout.svelte file) tells TypeScript that the type of data is whatever was returned from load:<!--- file: src/routes/blog/[slug]/+page.svelte --->\n<script>\n\t/** @type {import('./$types').PageData} */\n\texport let data;\n</script>In turn, annotating the load function with PageLoad, PageServerLoad, LayoutLoad or LayoutServerLoad (for +page.js, +page.server.js, +layout.js and +layout.server.js respectively) ensures that params and the return value are correctly typed.If you're using VS Code or any IDE that supports the language server protocol and TypeScript plugins then you can omit these types entirely! Svelte's IDE tooling will insert the correct types for you, so you'll get type checking without writing them yourself. It also works with our command line tool svelte-check.You can read more about omitting $types in our blog post about it."
          },
          {
            "title": "Routing > Other files",
            "content": "Any other files inside a route directory are ignored by SvelteKit. This means you can colocate components and utility modules with the routes that need them.If components and modules are needed by multiple routes, it's a good idea to put them in `$lib`."
          },
          {
            "title": "Routing > Further reading",
            "content": "undefined"
          },
          {
            "title": "Loading data",
            "content": "Before a `+page.svelte` component (and its containing `+layout.svelte` components) can be rendered, we often need to get some data. This is done by defining load functions."
          },
          {
            "title": "Loading data > Page data",
            "content": "A +page.svelte file can have a sibling +page.js that exports a load function, the return value of which is available to the page via the data prop: \n/** @type {import('./$types').PageLoad} */\nexport function load({ params }) {\n\treturn {\n\t\tpost: {\n\t\t\ttitle: `Title for ${params.slug} goes here`,\n\t\t\tcontent: `Content for ${params.slug} goes here`\n\t\t}\n\t};\n}<!--- file: src/routes/blog/[slug]/+page.svelte --->\n<script>\n\t/** @type {import('./$types').PageData} */\n\texport let data;\n</script>\n\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>Thanks to the generated $types module, we get full type safety.A load function in a +page.js file runs both on the server and in the browser (unless combined with export const ssr = false, in which case it will only run in the browser). If your load function should always run on the server (because it uses private environment variables, for example, or accesses a database) then it would go in a +page.server.js instead.A more realistic version of your blog post's load function, that only runs on the server and pulls data from a database, might look like this:import * as db from '$lib/server/database';\n\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ params }) {\n\treturn {\n\t\tpost: await db.getPost(params.slug)\n\t};\n}Notice that the type changed from PageLoad to PageServerLoad, because server load functions can access additional arguments. To understand when to use +page.js and when to use +page.server.js, see Universal vs server."
          },
          {
            "title": "Loading data > Layout data",
            "content": "Your +layout.svelte files can also load data, via +layout.js or +layout.server.js.import * as db from '$lib/server/database';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport async function load() {\n\treturn {\n\t\tposts: await db.getPostSummaries()\n\t};\n}<!--- file: src/routes/blog/[slug]/+layout.svelte --->\n<script>\n\t/** @type {import('./$types').LayoutData} */\n\texport let data;\n</script>\n\n<main>\n\t<!-- +page.svelte is rendered in this <slot> -->\n\t<slot />\n</main>\n\n<aside>\n\t<h2>More posts</h2>\n\t<ul>\n\t\t{#each data.posts as post}\n\t\t\t<li>\n\t\t\t\t<a href=\"/blog/{post.slug}\">\n\t\t\t\t\t{post.title}\n\t\t\t\t</a>\n\t\t\t</li>\n\t\t{/each}\n\t</ul>\n</aside>Data returned from layout load functions is available to child +layout.svelte components and the +page.svelte component as well as the layout that it 'belongs' to. \n<script>\n\t+++import { page } from '$app/stores';+++\n\n\t/** @type {import('./$types').PageData} */\n\texport let data;\n\n+++\t// we can access `data.posts` because it's returned from\n\t// the parent layout `load` function\n\tlet index = $derived(data.posts.findIndex(post => post.slug === $page.params.slug));\n\tlet next = $derived(data.posts[index - 1];)+++\n</script>\n\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n+++{#if next}\n\t<p>Next post: <a href=\"/blog/{next.slug}\">{next.title}</a></p>\n{/if}+++[!NOTE] If multiple `load` functions return data with the same key, the last one 'wins' — the result of a layout `load` returning `{ a: 1, b: 2 }` and a page `load` returning `{ b: 3, c: 4 }` would be `{ a: 1, b: 3, c: 4 }`."
          },
          {
            "title": "Loading data > $page.data",
            "content": "The +page.svelte component, and each +layout.svelte component above it, has access to its own data plus all the data from its parents.In some cases, we might need the opposite — a parent layout might need to access page data or data from a child layout. For example, the root layout might want to access a title property returned from a load function in +page.js or +page.server.js. This can be done with $page.data:<!--- file: src/routes/+layout.svelte --->\n<script>\n\timport { page } from '$app/stores';\n</script>\n\n<svelte:head>\n\t<title>{$page.data.title}</title>\n</svelte:head>Type information for $page.data is provided by App.PageData."
          },
          {
            "title": "Loading data > Universal vs server",
            "content": "As we've seen, there are two types of load function:undefined\nConceptually, they're the same thing, but there are some important differences to be aware of."
          },
          {
            "title": "Loading data > Universal vs server > When does which load function run?",
            "content": "Server load functions always run on the server.By default, universal load functions run on the server during SSR when the user first visits your page. They will then run again during hydration, reusing any responses from fetch requests. All subsequent invocations of universal load functions happen in the browser. You can customize the behavior through page options. If you disable server side rendering, you'll get an SPA and universal load functions always run on the client.If a route contains both universal and server load functions, the server load runs first.A load function is invoked at runtime, unless you prerender the page — in that case, it's invoked at build time."
          },
          {
            "title": "Loading data > Universal vs server > Input",
            "content": "Both universal and server load functions have access to properties describing the request (params, route and url) and various functions (fetch, setHeaders, parent, depends and untrack). These are described in the following sections.Server load functions are called with a ServerLoadEvent, which inherits clientAddress, cookies, locals, platform and request from RequestEvent.Universal load functions are called with a LoadEvent, which has a data property. If you have load functions in both +page.js and +page.server.js (or +layout.js and +layout.server.js), the return value of the server load function is the data property of the universal load function's argument."
          },
          {
            "title": "Loading data > Universal vs server > Output",
            "content": "A universal load function can return an object containing any values, including things like custom classes and component constructors.A server load function must return data that can be serialized with devalue — anything that can be represented as JSON plus things like BigInt, Date, Map, Set and RegExp, or repeated/cyclical references — so that it can be transported over the network. Your data can include promises, in which case it will be streamed to browsers."
          },
          {
            "title": "Loading data > Universal vs server > When to use which",
            "content": "Server load functions are convenient when you need to access data directly from a database or filesystem, or need to use private environment variables.Universal load functions are useful when you need to fetch data from an external API and don't need private credentials, since SvelteKit can get the data directly from the API rather than going via your server. They are also useful when you need to return something that can't be serialized, such as a Svelte component constructor.In rare cases, you might need to use both together — for example, you might need to return an instance of a custom class that was initialised with data from your server. When using both, the server load return value is not passed directly to the page, but to the universal load function (as the data property): \n/** @type {import('./$types').PageServerLoad} */\nexport async function load() {\n\treturn {\n\t\tserverMessage: 'hello from server load function'\n\t};\n} \n \n/** @type {import('./$types').PageLoad} */\nexport async function load({ data }) {\n\treturn {\n\t\tserverMessage: data.serverMessage,\n\t\tuniversalMessage: 'hello from universal load function'\n\t};\n}"
          },
          {
            "title": "Loading data > Using URL data",
            "content": "Often the load function depends on the URL in one way or another. For this, the load function provides you with url, route and params."
          },
          {
            "title": "Loading data > Using URL data > url",
            "content": "An instance of `URL`, containing properties like the origin, hostname, pathname and searchParams (which contains the parsed query string as a `URLSearchParams` object). url.hash cannot be accessed during load, since it is unavailable on the server.[!NOTE] In some environments this is derived from request headers during server-side rendering. If you're using [adapter-node](adapter-node), for example, you may need to configure the adapter in order for the URL to be correct."
          },
          {
            "title": "Loading data > Using URL data > route",
            "content": "Contains the name of the current route directory, relative to src/routes: \n/** @type {import('./$types').PageLoad} */\nexport function load({ route }) {\n\tconsole.log(route.id); // '/a/[b]/[...c]'\n}"
          },
          {
            "title": "Loading data > Using URL data > params",
            "content": "params is derived from url.pathname and route.id.Given a route.id of /a/[b]/[...c] and a url.pathname of /a/x/y/z, the params object would look like this:{\n\t\"b\": \"x\",\n\t\"c\": \"y/z\"\n}"
          },
          {
            "title": "Loading data > Making fetch requests",
            "content": "To get data from an external API or a +server.js handler, you can use the provided fetch function, which behaves identically to the native `fetch` web API with a few additional features:undefined\n \n/** @type {import('./$types').PageLoad} */\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\n\treturn { item };\n}"
          },
          {
            "title": "Loading data > Cookies",
            "content": "A server load function can get and set `cookies`.import * as db from '$lib/server/database';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}Cookies will only be passed through the provided fetch function if the target host is the same as the SvelteKit application or a more specific subdomain of it.For example, if SvelteKit is serving my.domain.com:undefined\nOther cookies will not be passed when credentials: 'include' is set, because SvelteKit does not know which domain which cookie belongs to (the browser does not pass this information along), so it's not safe to forward any of them. Use the handleFetch hook to work around it."
          },
          {
            "title": "Loading data > Headers",
            "content": "Both server and universal load functions have access to a setHeaders function that, when running on the server, can set headers for the response. (When running in the browser, setHeaders has no effect.) This is useful if you want the page to be cached, for example: \n \n/** @type {import('./$types').PageLoad} */\nexport async function load({ fetch, setHeaders }) {\n\tconst url = `https://cms.example.com/products.json`;\n\tconst response = await fetch(url);\n\n\t// cache the page for the same length of time\n\t// as the underlying data\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}Setting the same header multiple times (even in separate load functions) is an error — you can only set a given header once. You cannot add a set-cookie header with setHeaders — use cookies.set(name, value, options) instead."
          },
          {
            "title": "Loading data > Using parent data",
            "content": "Occasionally it's useful for a load function to access data from a parent load function, which can be done with await parent(): \n/** @type {import('./$types').LayoutLoad} */\nexport function load() {\n\treturn { a: 1 };\n} \n/** @type {import('./$types').LayoutLoad} */\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n} \n/** @type {import('./$types').PageLoad} */\nexport async function load({ parent }) {\n\tconst { a, b } = await parent();\n\treturn { c: a + b };\n}<!--- file: src/routes/abc/+page.svelte --->\n<script>\n\t/** @type {import('./$types').PageData} */\n\texport let data;\n</script>\n\n<!-- renders `1 + 2 = 3` -->\n<p>{data.a} + {data.b} = {data.c}</p>[!NOTE] Notice that the `load` function in `+page.js` receives the merged data from both layout `load` functions, not just the immediate parent.\nInside +page.server.js and +layout.server.js, parent returns data from parent +layout.server.js files.In +page.js or +layout.js it will return data from parent +layout.js files. However, a missing +layout.js is treated as a ({ data }) => data function, meaning that it will also return data from parent +layout.server.js files that are not 'shadowed' by a +layout.js fileTake care not to introduce waterfalls when using await parent(). Here, for example, getData(params) does not depend on the result of calling parent(), so we should call it first to avoid a delayed render./** @type {import('./$types').PageLoad} */\nexport async function load({ params, parent }) {\n\t---const parentData = await parent();---\n\tconst data = await getData(params);\n\t+++const parentData = await parent();+++\n\n\treturn {\n\t\t...data,\n\t\tmeta: { ...parentData.meta, ...data.meta }\n\t};\n}"
          },
          {
            "title": "Loading data > Errors",
            "content": "If an error is thrown during load, the nearest `+error.svelte` will be rendered. For _expected_ errors, use the error helper from @sveltejs/kit to specify the HTTP status code and an optional message:import { error } from '@sveltejs/kit';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n\n\tif (!locals.user.isAdmin) {\n\t\terror(403, 'not an admin');\n\t}\n}Calling error(...) will throw an exception, making it easy to stop execution from inside helper functions.If an _unexpected_ error is thrown, SvelteKit will invoke `handleError` and treat it as a 500 Internal Error.[!NOTE] [In SvelteKit 1.x](migrating-to-sveltekit-2#redirect-and-error-are-no-longer-thrown-by-you) you had to `throw` the error yourself"
          },
          {
            "title": "Loading data > Redirects",
            "content": "To redirect users, use the redirect helper from @sveltejs/kit to specify the location to which they should be redirected alongside a 3xx status code. Like error(...), calling redirect(...) will throw an exception, making it easy to stop execution from inside helper functions.import { redirect } from '@sveltejs/kit';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}[!NOTE] Don't use `redirect()` inside a `try {...}` block, as the redirect will immediately trigger the catch statement.\nIn the browser, you can also navigate programmatically outside of a load function using `goto` from `$app.navigation`.[!NOTE] [In SvelteKit 1.x](migrating-to-sveltekit-2#redirect-and-error-are-no-longer-thrown-by-you) you had to `throw` the `redirect` yourself"
          },
          {
            "title": "Loading data > Streaming with promises",
            "content": "When using a server load, promises will be streamed to the browser as they resolve. This is useful if you have slow, non-essential data, since you can start rendering the page before all the data is available:/** @type {import('./$types').PageServerLoad} */\nexport async function load({ params }) {\n\treturn {\n\t\t// make sure the `await` happens at the end, otherwise we\n\t\t// can't start loading comments until we've loaded the post\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}This is useful for creating skeleton loading states, for example:<!--- file: src/routes/blog/[slug]/+page.svelte --->\n<script>\n\t/** @type {import('./$types').PageData} */\n\texport let data;\n</script>\n\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n\tLoading comments...\n{:then comments}\n\t{#each comments as comment}\n\t\t<p>{comment.content}</p>\n\t{/each}\n{:catch error}\n\t<p>error loading comments: {error.message}</p>\n{/await}When streaming data, be careful to handle promise rejections correctly. More specifically, the server could crash with an &quot;unhandled promise rejection&quot; error if a lazy-loaded promise fails before rendering starts (at which point it's caught) and isn't handling the error in some way. When using SvelteKit's fetch directly in the load function, SvelteKit will handle this case for you. For other promises, it is enough to attach a noop-catch to the promise to mark it as handled. \n/** @type {import('./$types').PageServerLoad} */\nexport function load({ fetch }) {\n\tconst ok_manual = Promise.reject();\n\tok_manual.catch(() => {});\n\n\treturn {\n\t\tok_manual,\n\t\tok_fetch: fetch('/fetch/that/could/fail'),\n\t\tdangerous_unhandled: Promise.reject()\n\t};\n}[!NOTE] On platforms that do not support streaming, such as AWS Lambda or Firebase, responses will be buffered. This means the page will only render once all promises resolve. If you are using a proxy (e.g. NGINX), make sure it does not buffer responses from the proxied server.\n[!NOTE] Streaming data will only work when JavaScript is enabled. You should avoid returning promises from a universal `load` function if the page is server rendered, as these are _not_ streamed — instead, the promise is recreated when the function reruns in the browser.\n[!NOTE] The headers and status code of a response cannot be changed once the response has started streaming, therefore you cannot `setHeaders` or throw redirects inside a streamed promise.\n[!NOTE] [In SvelteKit 1.x](migrating-to-sveltekit-2#Top-level-promises-are-no-longer-awaited) top-level promises were automatically awaited, only nested promises were streamed."
          },
          {
            "title": "Loading data > Parallel loading",
            "content": "When rendering (or navigating to) a page, SvelteKit runs all load functions concurrently, avoiding a waterfall of requests. During client-side navigation, the result of calling multiple server load functions are grouped into a single response. Once all load functions have returned, the page is rendered."
          },
          {
            "title": "Loading data > Rerunning load functions",
            "content": "SvelteKit tracks the dependencies of each load function to avoid rerunning it unnecessarily during navigation.For example, given a pair of load functions like these...import * as db from '$lib/server/database';\n\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ params }) {\n\treturn {\n\t\tpost: await db.getPost(params.slug)\n\t};\n}import * as db from '$lib/server/database';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport async function load() {\n\treturn {\n\t\tposts: await db.getPostSummaries()\n\t};\n}...the one in +page.server.js will rerun if we navigate from /blog/trying-the-raw-meat-diet to /blog/i-regret-my-choices because params.slug has changed. The one in +layout.server.js will not, because the data is still valid. In other words, we won't call db.getPostSummaries() a second time.A load function that calls await parent() will also rerun if a parent load function is rerun.Dependency tracking does not apply after the load function has returned — for example, accessing params.x inside a nested promise will not cause the function to rerun when params.x changes. (Don't worry, you'll get a warning in development if you accidentally do this.) Instead, access the parameter in the main body of your load function.Search parameters are tracked independently from the rest of the url. For example, accessing event.url.searchParams.get(&quot;x&quot;) inside a load function will make that load function re-run when navigating from ?x=1 to ?x=2, but not when navigating from ?x=1&amp;y=1 to ?x=1&amp;y=2."
          },
          {
            "title": "Loading data > Rerunning load functions > Untracking dependencies",
            "content": "In rare cases, you may wish to exclude something from the dependency tracking mechanism. You can do this with the provided untrack function: \n/** @type {import('./$types').PageLoad} */\nexport async function load({ untrack, url }) {\n\t// Untrack url.pathname so that path changes don't trigger a rerun\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}"
          },
          {
            "title": "Loading data > Rerunning load functions > Manual invalidation",
            "content": "You can also rerun load functions that apply to the current page using `invalidate(url)`, which reruns all load functions that depend on url, and `invalidateAll()`, which reruns every load function. Server load functions will never automatically depend on a fetched url to avoid leaking secrets to the client.A load function depends on url if it calls fetch(url) or depends(url). Note that url can be a custom identifier that starts with [a-z]:: \n/** @type {import('./$types').PageLoad} */\nexport async function load({ fetch, depends }) {\n\t// load reruns when `invalidate('https://api.example.com/random-number')` is called...\n\tconst response = await fetch('https://api.example.com/random-number');\n\n\t// ...or when `invalidate('app:random')` is called\n\tdepends('app:random');\n\n\treturn {\n\t\tnumber: await response.json()\n\t};\n}<!--- file: src/routes/random-number/+page.svelte --->\n<script>\n\timport { invalidate, invalidateAll } from '$app/navigation';\n\n\t/** @type {import('./$types').PageData} */\n\texport let data;\n\n\tfunction rerunLoadFunction() {\n\t\t// any of these will cause the `load` function to rerun\n\t\tinvalidate('app:random');\n\t\tinvalidate('https://api.example.com/random-number');\n\t\tinvalidate(url => url.href.includes('random-number'));\n\t\tinvalidateAll();\n\t}\n</script>\n\n<p>random number: {data.number}</p>\n<button on:click={rerunLoadFunction}>Update random number</button>"
          },
          {
            "title": "Loading data > Rerunning load functions > When do load functions rerun?",
            "content": "To summarize, a load function will rerun in the following situations:undefined\nparams and url can change in response to a <a href=&quot;..&quot;> link click, a `<form>` interaction, a `goto` invocation, or a `redirect`.Note that rerunning a load function will update the data prop inside the corresponding +layout.svelte or +page.svelte; it does not cause the component to be recreated. As a result, internal state is preserved. If this isn't what you want, you can reset whatever you need to reset inside an `afterNavigate` callback, and/or wrap your component in a `{#key ...}` block."
          },
          {
            "title": "Loading data > Implications for authentication",
            "content": "A couple features of loading data have important implications for auth checks:undefined\nThere are a few possible strategies to ensure an auth check occurs before protected code.To prevent data waterfalls and preserve layout load caches:undefined\nPutting an auth guard in +layout.server.js requires all child pages to call await parent() before protected code. Unless every child page depends on returned data from await parent(), the other options will be more performant."
          },
          {
            "title": "Loading data > Further reading",
            "content": "undefined"
          },
          {
            "title": "Form actions",
            "content": "A +page.server.js file can export actions, which allow you to POST data to the server using the <form> element.When using <form>, client-side JavaScript is optional, but you can easily progressively enhance your form interactions with JavaScript to provide the best user experience."
          },
          {
            "title": "Form actions > Default actions",
            "content": "In the simplest case, a page declares a default action: \n/** @satisfies {import('./$types').Actions} */\nexport const actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};To invoke this action from the /login page, just add a <form> — no JavaScript needed:<!--- file: src/routes/login/+page.svelte --->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>If someone were to click the button, the browser would send the form data via POST request to the server, running the default action.[!NOTE] Actions always use `POST` requests, since `GET` requests should never have side-effects.\nWe can also invoke the action from other pages (for example if there's a login widget in the nav in the root layout) by adding the action attribute, pointing to the page: \n<form method=\"POST\" action=\"/login\">\n\t<!-- content -->\n</form>"
          },
          {
            "title": "Form actions > Named actions",
            "content": "Instead of one default action, a page can have as many named actions as it needs: \n/** @satisfies {import('./$types').Actions} */\nexport const actions = {\n---\tdefault: async (event) => {---\n+++\tlogin: async (event) => {+++\n\t\t// TODO log the user in\n\t},\n+++\tregister: async (event) => {\n\t\t// TODO register the user\n\t}+++\n};To invoke a named action, add a query parameter with the name prefixed by a / character:<!--- file: src/routes/login/+page.svelte --->\n<form method=\"POST\" action=\"?/register\"><!--- file: src/routes/+layout.svelte --->\n<form method=\"POST\" action=\"/login?/register\">As well as the action attribute, we can use the formaction attribute on a button to POST the same form data to a different action than the parent <form>: \n<form method=\"POST\" +++action=\"?/login\"+++>\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n\t+++<button formaction=\"?/register\">Register</button>+++\n</form>[!NOTE] We can't have default actions next to named actions, because if you POST to a named action without a redirect, the query parameter is persisted in the URL, which means the next default POST would go through the named action from before."
          },
          {
            "title": "Form actions > Anatomy of an action",
            "content": "Each action receives a RequestEvent object, allowing you to read the data with request.formData(). After processing the request (for example, logging the user in by setting a cookie), the action can respond with data that will be available through the form property on the corresponding page and through $page.form app-wide until the next update.import * as db from '$lib/server/db';\n\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ cookies }) {\n\tconst user = await db.getUserFromSession(cookies.get('sessionid'));\n\treturn { user };\n}\n\n/** @satisfies {import('./$types').Actions} */\nexport const actions = {\n\tlogin: async ({ cookies, request }) => {\n\t\tconst data = await request.formData();\n\t\tconst email = data.get('email');\n\t\tconst password = data.get('password');\n\n\t\tconst user = await db.getUser(email);\n\t\tcookies.set('sessionid', await db.createSession(user), { path: '/' });\n\n\t\treturn { success: true };\n\t},\n\tregister: async (event) => {\n\t\t// TODO register the user\n\t}\n};<!--- file: src/routes/login/+page.svelte --->\n<script>\n\t/** @type {import('./$types').PageData} */\n\texport let data;\n\n\t/** @type {import('./$types').ActionData} */\n\texport let form;\n</script>\n\n{#if form?.success}\n\t<!-- this message is ephemeral; it exists because the page was rendered in\n\t       response to a form submission. it will vanish if the user reloads -->\n\t<p>Successfully logged in! Welcome back, {data.user.name}</p>\n{/if}"
          },
          {
            "title": "Form actions > Anatomy of an action > Validation errors",
            "content": "If the request couldn't be processed because of invalid data, you can return validation errors — along with the previously submitted form values — back to the user so that they can try again. The fail function lets you return an HTTP status code (typically 400 or 422, in the case of validation errors) along with the data. The status code is available through $page.status and the data through form:+++import { fail } from '@sveltejs/kit';+++\nimport * as db from '$lib/server/db';\n\n/** @satisfies {import('./$types').Actions} */\nexport const actions = {\n\tlogin: async ({ cookies, request }) => {\n\t\tconst data = await request.formData();\n\t\tconst email = data.get('email');\n\t\tconst password = data.get('password');\n\n+++\t\tif (!email) {\n\t\t\treturn fail(400, { email, missing: true });\n\t\t}+++\n\n\t\tconst user = await db.getUser(email);\n\n+++\t\tif (!user || user.password !== db.hash(password)) {\n\t\t\treturn fail(400, { email, incorrect: true });\n\t\t}+++\n\n\t\tcookies.set('sessionid', await db.createSession(user), { path: '/' });\n\n\t\treturn { success: true };\n\t},\n\tregister: async (event) => {\n\t\t// TODO register the user\n\t}\n};[!NOTE] Note that as a precaution, we only return the email back to the page — not the password.\n \n<form method=\"POST\" action=\"?/login\">\n+++\t{#if form?.missing}<p class=\"error\">The email field is required</p>{/if}\n\t{#if form?.incorrect}<p class=\"error\">Invalid credentials!</p>{/if}+++\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\" +++value={form?.email ?? ''}+++>\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n\t<button formaction=\"?/register\">Register</button>\n</form>The returned data must be serializable as JSON. Beyond that, the structure is entirely up to you. For example, if you had multiple forms on the page, you could distinguish which <form> the returned form data referred to with an id property or similar."
          },
          {
            "title": "Form actions > Anatomy of an action > Redirects",
            "content": "Redirects (and errors) work exactly the same as in `load`:import { fail, +++redirect+++ } from '@sveltejs/kit';\nimport * as db from '$lib/server/db';\n\n/** @satisfies {import('./$types').Actions} */\nexport const actions = {\n\tlogin: async ({ cookies, request, +++url+++ }) => {\n\t\tconst data = await request.formData();\n\t\tconst email = data.get('email');\n\t\tconst password = data.get('password');\n\n\t\tconst user = await db.getUser(email);\n\t\tif (!user) {\n\t\t\treturn fail(400, { email, missing: true });\n\t\t}\n\n\t\tif (user.password !== db.hash(password)) {\n\t\t\treturn fail(400, { email, incorrect: true });\n\t\t}\n\n\t\tcookies.set('sessionid', await db.createSession(user), { path: '/' });\n\n+++\t\tif (url.searchParams.has('redirectTo')) {\n\t\t\tredirect(303, url.searchParams.get('redirectTo'));\n\t\t}+++\n\n\t\treturn { success: true };\n\t},\n\tregister: async (event) => {\n\t\t// TODO register the user\n\t}\n};"
          },
          {
            "title": "Form actions > Loading data",
            "content": "After an action runs, the page will be re-rendered (unless a redirect or an unexpected error occurs), with the action's return value available to the page as the form prop. This means that your page's load functions will run after the action completes.Note that handle runs before the action is invoked, and does not rerun before the load functions. This means that if, for example, you use handle to populate event.locals based on a cookie, you must update event.locals when you set or delete the cookie in an action:/** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tevent.locals.user = await getUser(event.cookies.get('sessionid'));\n\treturn resolve(event);\n}/** @type {import('./$types').PageServerLoad} */\nexport function load(event) {\n\treturn {\n\t\tuser: event.locals.user\n\t};\n}\n\n/** @satisfies {import('./$types').Actions} */\nexport const actions = {\n\tlogout: async (event) => {\n\t\tevent.cookies.delete('sessionid', { path: '/' });\n\t\tevent.locals.user = null;\n\t}\n};"
          },
          {
            "title": "Form actions > Progressive enhancement",
            "content": "In the preceding sections we built a /login action that works without client-side JavaScript — not a fetch in sight. That's great, but when JavaScript is available we can progressively enhance our form interactions to provide a better user experience."
          },
          {
            "title": "Form actions > Progressive enhancement > use:enhance",
            "content": "The easiest way to progressively enhance a form is to add the use:enhance action: \n<script>\n\t+++import { enhance } from '$app/forms';+++\n\n\t/** @type {import('./$types').ActionData} */\n\texport let form;\n</script>\n\n<form method=\"POST\" +++use:enhance+++>[!NOTE] `use:enhance` can only be used with forms that have `method=\"POST\"`. It will not work with `method=\"GET\"`, which is the default for forms without a specified method. Attempting to use `use:enhance` on forms without `method=\"POST\"` will result in an error.\n[!NOTE] Yes, it's a little confusing that the `enhance` action and `<form action>` are both called 'action'. These docs are action-packed. Sorry.\nWithout an argument, use:enhance will emulate the browser-native behaviour, just without the full-page reloads. It will:undefined"
          },
          {
            "title": "Form actions > Progressive enhancement > Customising use:enhance",
            "content": "To customise the behaviour, you can provide a SubmitFunction that runs immediately before the form is submitted, and (optionally) returns a callback that runs with the ActionResult. Note that if you return a callback, the default behavior mentioned above is not triggered. To get it back, call update.<form\n\tmethod=\"POST\"\n\tuse:enhance={({ formElement, formData, action, cancel, submitter }) => {\n\t\t// `formElement` is this `<form>` element\n\t\t// `formData` is its `FormData` object that's about to be submitted\n\t\t// `action` is the URL to which the form is posted\n\t\t// calling `cancel()` will prevent the submission\n\t\t// `submitter` is the `HTMLElement` that caused the form to be submitted\n\n\t\treturn async ({ result, update }) => {\n\t\t\t// `result` is an `ActionResult` object\n\t\t\t// `update` is a function which triggers the default logic that would be triggered if this callback wasn't set\n\t\t};\n\t}}\n>You can use these functions to show and hide loading UI, and so on.If you return a callback, you may need to reproduce part of the default use:enhance behaviour, but without invalidating all data on a successful response. You can do so with applyAction: \n<script>\n\timport { enhance, +++applyAction+++ } from '$app/forms';\n\n\t/** @type {import('./$types').ActionData} */\n\texport let form;\n</script>\n\n<form\n\tmethod=\"POST\"\n\tuse:enhance={({ formElement, formData, action, cancel }) => {\n\t\treturn async ({ result }) => {\n\t\t\t// `result` is an `ActionResult` object\n+++\t\t\tif (result.type === 'redirect') {\n\t\t\t\tgoto(result.location);\n\t\t\t} else {\n\t\t\t\tawait applyAction(result);\n\t\t\t}+++\n\t\t};\n\t}}\n>The behaviour of applyAction(result) depends on result.type:undefined\nIn all cases, focus will be reset."
          },
          {
            "title": "Form actions > Progressive enhancement > Custom event listener",
            "content": "We can also implement progressive enhancement ourselves, without use:enhance, with a normal event listener on the <form>:<!--- file: src/routes/login/+page.svelte --->\n<script>\n\timport { invalidateAll, goto } from '$app/navigation';\n\timport { applyAction, deserialize } from '$app/forms';\n\n\t/** @type {import('./$types').ActionData} */\n\texport let form;\n\n\t/** @type {any} */\n\tlet error;\n\n\t/** @param {{ currentTarget: EventTarget & HTMLFormElement}} event */\n\tasync function handleSubmit(event) {\n\t\tconst data = new FormData(event.currentTarget);\n\n\t\tconst response = await fetch(event.currentTarget.action, {\n\t\t\tmethod: 'POST',\n\t\t\tbody: data\n\t\t});\n\n\t\t/** @type {import('@sveltejs/kit').ActionResult} */\n\t\tconst result = deserialize(await response.text());\n\n\t\tif (result.type === 'success') {\n\t\t\t// rerun all `load` functions, following the successful update\n\t\t\tawait invalidateAll();\n\t\t}\n\n\t\tapplyAction(result);\n\t}\n</script>\n\n<form method=\"POST\" on:submit|preventDefault={handleSubmit}>\n\t<!-- content -->\n</form>Note that you need to deserialize the response before processing it further using the corresponding method from $app/forms. JSON.parse() isn't enough because form actions - like load functions - also support returning Date or BigInt objects.If you have a +server.js alongside your +page.server.js, fetch requests will be routed there by default. To POST to an action in +page.server.js instead, use the custom x-sveltekit-action header:const response = await fetch(this.action, {\n\tmethod: 'POST',\n\tbody: data,\n+++\theaders: {\n\t\t'x-sveltekit-action': 'true'\n\t}+++\n});"
          },
          {
            "title": "Form actions > Alternatives",
            "content": "Form actions are the preferred way to send data to the server, since they can be progressively enhanced, but you can also use `+server.js` files to expose (for example) a JSON API. Here's how such an interaction could look like:<!--- file: src/routes/send-message/+page.svelte --->\n<script>\n\tfunction rerun() {\n\t\tfetch('/api/ci', {\n\t\t\tmethod: 'POST'\n\t\t});\n\t}\n</script>\n\n<button on:click={rerun}>Rerun CI</button> \n \n/** @type {import('./$types').RequestHandler} */\nexport function POST() {\n\t// do something\n}"
          },
          {
            "title": "Form actions > GET vs POST",
            "content": "As we've seen, to invoke a form action you must use method=&quot;POST&quot;.Some forms don't need to POST data to the server — search inputs, for example. For these you can use method=&quot;GET&quot; (or, equivalently, no method at all), and SvelteKit will treat them like <a> elements, using the client-side router instead of a full page navigation:<form action=\"/search\">\n\t<label>\n\t\tSearch\n\t\t<input name=\"q\">\n\t</label>\n</form>Submitting this form will navigate to /search?q=... and invoke your load function but will not invoke an action. As with <a> elements, you can set the `data-sveltekit-reload`, `data-sveltekit-replacestate`, `data-sveltekit-keepfocus` and `data-sveltekit-noscroll` attributes on the <form> to control the router's behaviour."
          },
          {
            "title": "Form actions > Further reading",
            "content": "undefined"
          },
          {
            "title": "Page options",
            "content": "By default, SvelteKit will render (or prerender) any component first on the server and send it to the client as HTML. It will then render the component again in the browser to make it interactive in a process called **hydration**. For this reason, you need to ensure that components can run in both places. SvelteKit will then initialize a **router** that takes over subsequent navigations.You can control each of these on a page-by-page basis by exporting options from `+page.js` or `+page.server.js`, or for groups of pages using a shared `+layout.js` or `+layout.server.js`. To define an option for the whole app, export it from the root layout. Child layouts and pages override values set in parent layouts, so — for example — you can enable prerendering for your entire app then disable it for pages that need to be dynamically rendered.You can mix and match these options in different areas of your app. For example you could prerender your marketing page for maximum speed, server-render your dynamic pages for SEO and accessibility and turn your admin section into an SPA by rendering it on the client only. This makes SvelteKit very versatile."
          },
          {
            "title": "Page options > prerender",
            "content": "It's likely that at least some routes of your app can be represented as a simple HTML file generated at build time. These routes can be _prerendered_. \nexport const prerender = true;Alternatively, you can set export const prerender = true in your root +layout.js or +layout.server.js and prerender everything except pages that are explicitly marked as not prerenderable: \nexport const prerender = false;Routes with prerender = true will be excluded from manifests used for dynamic SSR, making your server (or serverless/edge functions) smaller. In some cases you might want to prerender a route but also include it in the manifest (for example, with a route like /blog/[slug] where you want to prerender your most recent/popular content but server-render the long tail) — for these cases, there's a third option, 'auto': \nexport const prerender = 'auto';[!NOTE] If your entire app is suitable for prerendering, you can use [`adapter-static`](https://github.com/sveltejs/kit/tree/main/packages/adapter-static), which will output files suitable for use with any static webserver.\nThe prerenderer will start at the root of your app and generate files for any prerenderable pages or +server.js routes it finds. Each page is scanned for <a> elements that point to other pages that are candidates for prerendering — because of this, you generally don't need to specify which pages should be accessed. If you do need to specify which pages should be accessed by the prerenderer, you can do so with `config.kit.prerender.entries`, or by exporting an `entries` function from your dynamic route.While prerendering, the value of building imported from `$app/environment` will be true."
          },
          {
            "title": "Page options > prerender > Prerendering server routes",
            "content": "Unlike the other page options, prerender also applies to +server.js files. These files are not affected by layouts, but will inherit default values from the pages that fetch data from them, if any. For example if a +page.js contains this load function... \nexport const prerender = true;\n\n/** @type {import('./$types').PageLoad} */\nexport async function load({ fetch }) {\n\tconst res = await fetch('/my-server-route.json');\n\treturn await res.json();\n}...then src/routes/my-server-route.json/+server.js will be treated as prerenderable if it doesn't contain its own export const prerender = false."
          },
          {
            "title": "Page options > prerender > When not to prerender",
            "content": "The basic rule is this: for a page to be prerenderable, any two users hitting it directly must get the same content from the server.[!NOTE] Not all pages are suitable for prerendering. Any content that is prerendered will be seen by all users. You can of course fetch personalized data in `onMount` in a prerendered page, but this may result in a poorer user experience since it will involve blank initial content or loading indicators.\nNote that you can still prerender pages that load data based on the page's parameters, such as a src/routes/blog/[slug]/+page.svelte route.Accessing `url.searchParams` during prerendering is forbidden. If you need to use it, ensure you are only doing so in the browser (for example in onMount).Pages with actions cannot be prerendered, because a server must be able to handle the action POST requests."
          },
          {
            "title": "Page options > prerender > Route conflicts",
            "content": "Because prerendering writes to the filesystem, it isn't possible to have two endpoints that would cause a directory and a file to have the same name. For example, src/routes/foo/+server.js and src/routes/foo/bar/+server.js would try to create foo and foo/bar, which is impossible.For that reason among others, it's recommended that you always include a file extension — src/routes/foo.json/+server.js and src/routes/foo/bar.json/+server.js would result in foo.json and foo/bar.json files living harmoniously side-by-side.For pages, we skirt around this problem by writing foo/index.html instead of foo."
          },
          {
            "title": "Page options > prerender > Troubleshooting",
            "content": "If you encounter an error like 'The following routes were marked as prerenderable, but were not prerendered' it's because the route in question (or a parent layout, if it's a page) has export const prerender = true but the page wasn't reached by the prerendering crawler and thus wasn't prerendered.Since these routes cannot be dynamically server-rendered, this will cause errors when people try to access the route in question. There are a few ways to fix it:undefined"
          },
          {
            "title": "Page options > entries",
            "content": "SvelteKit will discover pages to prerender automatically, by starting at entry points and crawling them. By default, all your non-dynamic routes are considered entry points — for example, if you have these routes.../             # non-dynamic\n/blog         # non-dynamic\n/blog/[slug]  # dynamic, because of `[slug]`...SvelteKit will prerender / and /blog, and in the process discover links like <a href=&quot;/blog/hello-world&quot;> which give it new pages to prerender.Most of the time, that's enough. In some situations, links to pages like /blog/hello-world might not exist (or might not exist on prerendered pages), in which case we need to tell SvelteKit about their existence.This can be done with `config.kit.prerender.entries`, or by exporting an entries function from a +page.js, a +page.server.js or a +server.js belonging to a dynamic route: \n/** @type {import('./$types').EntryGenerator} */\nexport function entries() {\n\treturn [\n\t\t{ slug: 'hello-world' },\n\t\t{ slug: 'another-blog-post' }\n\t];\n}\n\nexport const prerender = true;entries can be an async function, allowing you to (for example) retrieve a list of posts from a CMS or database, in the example above."
          },
          {
            "title": "Page options > ssr",
            "content": "Normally, SvelteKit renders your page on the server first and sends that HTML to the client where it's hydrated. If you set ssr to false, it renders an empty 'shell' page instead. This is useful if your page is unable to be rendered on the server (because you use browser-only globals like document for example), but in most situations it's not recommended (see appendix). \nexport const ssr = false;\n// If both `ssr` and `csr` are `false`, nothing will be rendered!If you add export const ssr = false to your root +layout.js, your entire app will only be rendered on the client — which essentially means you turn your app into an SPA."
          },
          {
            "title": "Page options > csr",
            "content": "Ordinarily, SvelteKit hydrates your server-rendered HTML into an interactive client-side-rendered (CSR) page. Some pages don't require JavaScript at all — many blog posts and 'about' pages fall into this category. In these cases you can disable CSR: \nexport const csr = false;\n// If both `csr` and `ssr` are `false`, nothing will be rendered!Disabling CSR does not ship any JavaScript to the client. This means:undefined\nYou can enable csr during development (for example to take advantage of HMR) like so: \nimport { dev } from '$app/environment';\n\nexport const csr = dev;"
          },
          {
            "title": "Page options > trailingSlash",
            "content": "By default, SvelteKit will remove trailing slashes from URLs — if you visit /about/, it will respond with a redirect to /about. You can change this behaviour with the trailingSlash option, which can be one of 'never' (the default), 'always', or 'ignore'.As with other page options, you can export this value from a +layout.js or a +layout.server.js and it will apply to all child pages. You can also export the configuration from +server.js files. \nexport const trailingSlash = 'always';This option also affects prerendering. If trailingSlash is always, a route like /about will result in an about/index.html file, otherwise it will create about.html, mirroring static webserver conventions.[!NOTE] Ignoring trailing slashes is not recommended — the semantics of relative paths differ between the two cases (`./y` from `/x` is `/y`, but from `/x/` is `/x/y`), and `/x` and `/x/` are treated as separate URLs which is harmful to SEO."
          },
          {
            "title": "Page options > config",
            "content": "With the concept of adapters, SvelteKit is able to run on a variety of platforms. Each of these might have specific configuration to further tweak the deployment — for example on Vercel you could choose to deploy some parts of your app on the edge and others on serverless environments.config is an object with key-value pairs at the top level. Beyond that, the concrete shape is dependent on the adapter you're using. Every adapter should provide a Config interface to import for type safety. Consult the documentation of your adapter for more information. \n/** @type {import('some-adapter').Config} */\nexport const config = {\n\truntime: 'edge'\n};config objects are merged at the top level (but not deeper levels). This means you don't need to repeat all the values in a +page.js if you want to only override some of the values in the upper +layout.js. For example this layout configuration... \nexport const config = {\n\truntime: 'edge',\n\tregions: 'all',\n\tfoo: {\n\t\tbar: true\n\t}\n}...is overridden by this page configuration... \nexport const config = {\n\tregions: ['us1', 'us2'],\n\tfoo: {\n\t\tbaz: true\n\t}\n}...which results in the config value { runtime: 'edge', regions: ['us1', 'us2'], foo: { baz: true } } for that page."
          },
          {
            "title": "Page options > Further reading",
            "content": "undefined"
          },
          {
            "title": "State management",
            "content": "If you're used to building client-only apps, state management in an app that spans server and client might seem intimidating. This section provides tips for avoiding some common gotchas."
          },
          {
            "title": "State management > Avoid shared state on the server",
            "content": "Browsers are stateful — state is stored in memory as the user interacts with the application. Servers, on the other hand, are stateless — the content of the response is determined entirely by the content of the request.Conceptually, that is. In reality, servers are often long-lived and shared by multiple users. For that reason it's important not to store data in shared variables. For example, consider this code: \n \nlet user;\n\n/** @type {import('./$types').PageServerLoad} */\nexport function load() {\n\treturn { user };\n}\n\n/** @satisfies {import('./$types').Actions} */\nexport const actions = {\n\tdefault: async ({ request }) => {\n\t\tconst data = await request.formData();\n\n\t\t// NEVER DO THIS!\n\t\tuser = {\n\t\t\tname: data.get('name'),\n\t\t\tembarrassingSecret: data.get('secret')\n\t\t};\n\t}\n}The user variable is shared by everyone who connects to this server. If Alice submitted an embarrassing secret, and Bob visited the page after her, Bob would know Alice's secret. In addition, when Alice returns to the site later in the day, the server may have restarted, losing her data.Instead, you should authenticate the user using `cookies` and persist the data to a database."
          },
          {
            "title": "State management > No side-effects in load",
            "content": "For the same reason, your load functions should be pure — no side-effects (except maybe the occasional console.log(...)). For example, you might be tempted to write to a store inside a load function so that you can use the store value in your components:import { user } from '$lib/user';\n\n/** @type {import('./$types').PageLoad} */\nexport async function load({ fetch }) {\n\tconst response = await fetch('/api/user');\n\n\t// NEVER DO THIS!\n\tuser.set(await response.json());\n}As with the previous example, this puts one user's information in a place that is shared by all users. Instead, just return the data... \n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ fetch }) {\n\tconst response = await fetch('/api/user');\n\n+++\treturn {\n\t\tuser: await response.json()\n\t};+++\n}...and pass it around to the components that need it, or use `$page.data`.If you're not using SSR, then there's no risk of accidentally exposing one user's data to another. But you should still avoid side-effects in your load functions — your application will be much easier to reason about without them."
          },
          {
            "title": "State management > Using stores with context",
            "content": "You might wonder how we're able to use $page.data and other app stores if we can't use our own stores. The answer is that app stores on the server use Svelte's context API — the store is attached to the component tree with setContext, and when you subscribe you retrieve it with getContext. We can do the same thing with our own stores:<!--- file: src/routes/+layout.svelte --->\n<script>\n\timport { setContext } from 'svelte';\n\timport { writable } from 'svelte/store';\n\n\t/** @type {import('./$types').LayoutData} */\n\texport let data;\n\n\t// Create a store and update it when necessary...\n\tconst user = writable();\n\t$: user.set(data.user);\n\n\t// ...and add it to the context for child components to access\n\tsetContext('user', user);\n</script><!--- file: src/routes/user/+page.svelte --->\n<script>\n\timport { getContext } from 'svelte';\n\n\t// Retrieve user store from context\n\tconst user = getContext('user');\n</script>\n\n<p>Welcome {$user.name}</p>Updating the value of a context-based store in deeper-level pages or components while the page is being rendered via SSR will not affect the value in the parent component because it has already been rendered by the time the store value is updated. In contrast, on the client (when CSR is enabled, which is the default) the value will be propagated and components, pages, and layouts higher in the hierarchy will react to the new value. Therefore, to avoid values 'flashing' during state updates during hydration, it is generally recommended to pass state down into components rather than up.If you're not using SSR (and can guarantee that you won't need to use SSR in future) then you can safely keep state in a shared module, without using the context API."
          },
          {
            "title": "State management > Component and page state is preserved",
            "content": "When you navigate around your application, SvelteKit reuses existing layout and page components. For example, if you have a route like this...<!--- file: src/routes/blog/[slug]/+page.svelte --->\n<script>\n\t/** @type {import('./$types').PageData} */\n\texport let data;\n\n\t// THIS CODE IS BUGGY!\n\tconst wordCount = data.content.split(' ').length;\n\tconst estimatedReadingTime = wordCount / 250;\n</script>\n\n<header>\n\t<h1>{data.title}</h1>\n\t<p>Reading time: {Math.round(estimatedReadingTime)} minutes</p>\n</header>\n\n<div>{@html data.content}</div>...then navigating from /blog/my-short-post to /blog/my-long-post won't cause the layout, page and any other components within to be destroyed and recreated. Instead the data prop (and by extension data.title and data.content) will update (as it would with any other Svelte component) and, because the code isn't rerunning, lifecycle methods like onMount and onDestroy won't rerun and estimatedReadingTime won't be recalculated.Instead, we need to make the value _reactive_: \n<script>\n\t/** @type {import('./$types').PageData} */\n\texport let data;\n\n+++\tlet wordCount = $state(data.content.split(' ').length);\n\tlet estimatedReadingTime = $derived(wordCount / 250);+++\n</script>[!NOTE] If your code in `onMount` and `onDestroy` has to run again after navigation you can use [afterNavigate]($app-navigation#afterNavigate) and [beforeNavigate]($app-navigation#beforeNavigate) respectively.\nReusing components like this means that things like sidebar scroll state are preserved, and you can easily animate between changing values. In the case that you do need to completely destroy and remount a component on navigation, you can use this pattern:{#key $page.url.pathname}\n\t<BlogPost title={data.title} content={data.title} />\n{/key}"
          },
          {
            "title": "State management > Storing state in the URL",
            "content": "If you have state that should survive a reload and/or affect SSR, such as filters or sorting rules on a table, URL search parameters (like ?sort=price&amp;order=ascending) are a good place to put them. You can put them in <a href=&quot;...&quot;> or <form action=&quot;...&quot;> attributes, or set them programmatically via goto('?key=value'). They can be accessed inside load functions via the url parameter, and inside components via $page.url.searchParams."
          },
          {
            "title": "State management > Storing ephemeral state in snapshots",
            "content": "Some UI state, such as 'is the accordion open?', is disposable — if the user navigates away or refreshes the page, it doesn't matter if the state is lost. In some cases, you do want the data to persist if the user navigates to a different page and comes back, but storing the state in the URL or in a database would be overkill. For this, SvelteKit provides snapshots, which let you associate component state with a history entry."
          }
        ]
      },
      {
        "section": "Advanced",
        "blocks": [
          {
            "title": "Advanced routing > Rest parameters",
            "content": "If the number of route segments is unknown, you can use rest syntax — for example you might implement GitHub's file viewer like so.../[org]/[repo]/tree/[branch]/[...file]...in which case a request for /sveltejs/kit/tree/main/documentation/docs/04-advanced-routing.md would result in the following parameters being available to the page: \n{\n\torg: 'sveltejs',\n\trepo: 'kit',\n\tbranch: 'main',\n\tfile: 'documentation/docs/04-advanced-routing.md'\n}[!NOTE] `src/routes/a/[...rest]/z/+page.svelte` will match `/a/z` (i.e. there's no parameter at all) as well as `/a/b/z` and `/a/b/c/z` and so on. Make sure you check that the value of the rest parameter is valid, for example using a [matcher](#Matching)."
          },
          {
            "title": "Advanced routing > Rest parameters > 404 pages",
            "content": "Rest parameters also allow you to render custom 404s. Given these routes...src/routes/\n├ marx-brothers/\n│ ├ chico/\n│ ├ harpo/\n│ ├ groucho/\n│ └ +error.svelte\n└ +error.svelte...the marx-brothers/+error.svelte file will not be rendered if you visit /marx-brothers/karl, because no route was matched. If you want to render the nested error page, you should create a route that matches any /marx-brothers/* request, and return a 404 from it:src/routes/\n├ marx-brothers/\n+++| ├ [...path]/+++\n│ ├ chico/\n│ ├ harpo/\n│ ├ groucho/\n│ └ +error.svelte\n└ +error.svelte \nimport { error } from '@sveltejs/kit';\n\n/** @type {import('./$types').PageLoad} */\nexport function load(event) {\n\terror(404, 'Not Found');\n}[!NOTE] If you don't handle 404 cases, they will appear in [`handleError`](hooks#Shared-hooks-handleError)"
          },
          {
            "title": "Advanced routing > Optional parameters",
            "content": "A route like [lang]/home contains a parameter named lang which is required. Sometimes it's beneficial to make these parameters optional, so that in this example both home and en/home point to the same page. You can do that by wrapping the parameter in another bracket pair: [[lang]]/homeNote that an optional route parameter cannot follow a rest parameter ([...rest]/[[optional]]), since parameters are matched 'greedily' and the optional parameter would always be unused."
          },
          {
            "title": "Advanced routing > Matching",
            "content": "A route like src/routes/fruits/[page] would match /fruits/apple, but it would also match /fruits/rocketship. We don't want that. You can ensure that route parameters are well-formed by adding a matcher — which takes the parameter string (&quot;apple&quot; or &quot;rocketship&quot;) and returns true if it is valid — to your `params` directory... \n/**\n * @param {string} param\n * @return {param is ('apple' | 'orange')}\n * @satisfies {import('@sveltejs/kit').ParamMatcher}\n */\nexport function match(param) {\n\treturn param === 'apple' || param === 'orange';\n}...and augmenting your routes:src/routes/fruits/[page+++=fruit+++]If the pathname doesn't match, SvelteKit will try to match other routes (using the sort order specified below), before eventually returning a 404.Each module in the params directory corresponds to a matcher, with the exception of *.test.js and *.spec.js files which may be used to unit test your matchers.[!NOTE] Matchers run both on the server and in the browser."
          },
          {
            "title": "Advanced routing > Sorting",
            "content": "It's possible for multiple routes to match a given path. For example each of these routes would match /foo-abc:src/routes/[...catchall]/+page.svelte\nsrc/routes/[[a=x]]/+page.svelte\nsrc/routes/[b]/+page.svelte\nsrc/routes/foo-[c]/+page.svelte\nsrc/routes/foo-abc/+page.svelteSvelteKit needs to know which route is being requested. To do so, it sorts them according to the following rules...undefined\n...resulting in this ordering, meaning that /foo-abc will invoke src/routes/foo-abc/+page.svelte, and /foo-def will invoke src/routes/foo-[c]/+page.svelte rather than less specific routes:src/routes/foo-abc/+page.svelte\nsrc/routes/foo-[c]/+page.svelte\nsrc/routes/[[a=x]]/+page.svelte\nsrc/routes/[b]/+page.svelte\nsrc/routes/[...catchall]/+page.svelte"
          },
          {
            "title": "Advanced routing > Encoding",
            "content": "Some characters can't be used on the filesystem — / on Linux and Mac, \\ / : * ? &quot; < > | on Windows. The # and % characters have special meaning in URLs, and the [ ] ( ) characters have special meaning to SvelteKit, so these also can't be used directly as part of your route.To use these characters in your routes, you can use hexadecimal escape sequences, which have the format [x+nn] where nn is a hexadecimal character code:undefined\nFor example, to create a /smileys/:-) route, you would create a src/routes/smileys/[x+3a]-[x+29]/+page.svelte file.You can determine the hexadecimal code for a character with JavaScript:':'.charCodeAt(0).toString(16); // '3a', hence '[x+3a]'You can also use Unicode escape sequences. Generally you won't need to as you can use the unencoded character directly, but if — for some reason — you can't have a filename with an emoji in it, for example, then you can use the escaped characters. In other words, these are equivalent:src/routes/[u+d83e][u+dd2a]/+page.svelte\nsrc/routes/🤪/+page.svelteThe format for a Unicode escape sequence is [u+nnnn] where nnnn is a valid value between 0000 and 10ffff. (Unlike JavaScript string escaping, there's no need to use surrogate pairs to represent code points above ffff.) To learn more about Unicode encodings, consult Programming with Unicode.[!NOTE] Since TypeScript [struggles](https://github.com/microsoft/TypeScript/issues/13399) with directories with a leading `.` character, you may find it useful to encode these characters when creating e.g. [`.well-known`](https://en.wikipedia.org/wiki/Well-known_URI) routes: `src/routes/[x+2e]well-known/...`"
          },
          {
            "title": "Advanced routing > Advanced layouts",
            "content": "By default, the layout hierarchy mirrors the route hierarchy. In some cases, that might not be what you want."
          },
          {
            "title": "Advanced routing > Advanced layouts > (group)",
            "content": "Perhaps you have some routes that are 'app' routes that should have one layout (e.g. /dashboard or /item), and others that are 'marketing' routes that should have a different layout (/about or /testimonials). We can group these routes with a directory whose name is wrapped in parentheses — unlike normal directories, (app) and (marketing) do not affect the URL pathname of the routes inside them:src/routes/\n+++│ (app)/+++\n│ ├ dashboard/\n│ ├ item/\n│ └ +layout.svelte\n+++│ (marketing)/+++\n│ ├ about/\n│ ├ testimonials/\n│ └ +layout.svelte\n├ admin/\n└ +layout.svelteYou can also put a +page directly inside a (group), for example if / should be an (app) or a (marketing) page."
          },
          {
            "title": "Advanced routing > Advanced layouts > Breaking out of layouts",
            "content": "The root layout applies to every page of your app — if omitted, it defaults to <slot />. If you want some pages to have a different layout hierarchy than the rest, then you can put your entire app inside one or more groups except the routes that should not inherit the common layouts.In the example above, the /admin route does not inherit either the (app) or (marketing) layouts."
          },
          {
            "title": "Advanced routing > Advanced layouts > +page@",
            "content": "Pages can break out of the current layout hierarchy on a route-by-route basis. Suppose we have an /item/[id]/embed route inside the (app) group from the previous example:src/routes/\n├ (app)/\n│ ├ item/\n│ │ ├ [id]/\n│ │ │ ├ embed/\n+++│ │ │ │ └ +page.svelte+++\n│ │ │ └ +layout.svelte\n│ │ └ +layout.svelte\n│ └ +layout.svelte\n└ +layout.svelteOrdinarily, this would inherit the root layout, the (app) layout, the item layout and the [id] layout. We can reset to one of those layouts by appending @ followed by the segment name — or, for the root layout, the empty string. In this example, we can choose from the following options:undefined\nsrc/routes/\n├ (app)/\n│ ├ item/\n│ │ ├ [id]/\n│ │ │ ├ embed/\n+++│ │ │ │ └ +page@(app).svelte+++\n│ │ │ └ +layout.svelte\n│ │ └ +layout.svelte\n│ └ +layout.svelte\n└ +layout.svelte"
          },
          {
            "title": "Advanced routing > Advanced layouts > +layout@",
            "content": "Like pages, layouts can themselves break out of their parent layout hierarchy, using the same technique. For example, a +layout@.svelte component would reset the hierarchy for all its child routes.src/routes/\n├ (app)/\n│ ├ item/\n│ │ ├ [id]/\n│ │ │ ├ embed/\n│ │ │ │ └ +page.svelte  // uses (app)/item/[id]/+layout.svelte\n│ │ │ ├ +layout.svelte  // inherits from (app)/item/+layout@.svelte\n│ │ │ └ +page.svelte    // uses (app)/item/+layout@.svelte\n│ │ └ +layout@.svelte   // inherits from root layout, skipping (app)/+layout.svelte\n│ └ +layout.svelte\n└ +layout.svelte"
          },
          {
            "title": "Advanced routing > Advanced layouts > When to use layout groups",
            "content": "Not all use cases are suited for layout grouping, nor should you feel compelled to use them. It might be that your use case would result in complex (group) nesting, or that you don't want to introduce a (group) for a single outlier. It's perfectly fine to use other means such as composition (reusable load functions or Svelte components) or if-statements to achieve what you want. The following example shows a layout that rewinds to the root layout and reuses components and functions that other layouts can also use:<!--- file: src/routes/nested/route/+layout@.svelte --->\n<script>\n\timport ReusableLayout from '$lib/ReusableLayout.svelte';\n\texport let data;\n</script>\n\n<ReusableLayout {data}>\n\t<slot />\n</ReusableLayout>import { reusableLoad } from '$lib/reusable-load-function';\n\n/** @type {import('./$types').PageLoad} */\nexport function load(event) {\n\t// Add additional logic here, if needed\n\treturn reusableLoad(event);\n}"
          },
          {
            "title": "Advanced routing > Further reading",
            "content": "undefined"
          },
          {
            "title": "Hooks",
            "content": "'Hooks' are app-wide functions you declare that SvelteKit will call in response to specific events, giving you fine-grained control over the framework's behaviour.There are three hooks files, all optional:undefined\nCode in these modules will run when the application starts up, making them useful for initializing database clients and so on.[!NOTE] You can configure the location of these files with [`config.kit.files.hooks`](configuration#files)."
          },
          {
            "title": "Hooks > Server hooks",
            "content": "The following hooks can be added to src/hooks.server.js:"
          },
          {
            "title": "Hooks > Server hooks > handle",
            "content": "This function runs every time the SvelteKit server receives a request — whether that happens while the app is running, or during prerendering — and determines the response. It receives an event object representing the request and a function called resolve, which renders the route and generates a Response. This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example). \n/** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tif (event.url.pathname.startsWith('/custom')) {\n\t\treturn new Response('custom response');\n\t}\n\n\tconst response = await resolve(event);\n\treturn response;\n}[!NOTE] Requests for static assets — which includes pages that were already prerendered — are _not_ handled by SvelteKit.\nIf unimplemented, defaults to ({ event, resolve }) => resolve(event). To add custom data to the request, which is passed to handlers in +server.js and server load functions, populate the event.locals object, as shown below./** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tevent.locals.user = await getUserInformation(event.cookies.get('sessionid'));\n\n\tconst response = await resolve(event);\n\tresponse.headers.set('x-custom-header', 'potato');\n\n\treturn response;\n}You can define multiple handle functions and execute them with the `sequence` helper function.resolve also supports a second, optional parameter that gives you more control over how the response will be rendered. That parameter is an object that can have the following fields:undefined\n \n/** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tconst response = await resolve(event, {\n\t\ttransformPageChunk: ({ html }) => html.replace('old', 'new'),\n\t\tfilterSerializedResponseHeaders: (name) => name.startsWith('x-'),\n\t\tpreload: ({ type, path }) => type === 'js' || path.includes('/important/')\n\t});\n\n\treturn response;\n}Note that resolve(...) will never throw an error, it will always return a Promise<Response> with the appropriate status code. If an error is thrown elsewhere during handle, it is treated as fatal, and SvelteKit will respond with a JSON representation of the error or a fallback error page — which can be customised via src/error.html — depending on the Accept header. You can read more about error handling here."
          },
          {
            "title": "Hooks > Server hooks > handleFetch",
            "content": "This function allows you to modify (or replace) a fetch request that happens inside a load or action function that runs on the server (or during pre-rendering).For example, your load function might make a request to a public URL like https://api.yourapp.com when the user performs a client-side navigation to the respective page, but during SSR it might make sense to hit the API directly (bypassing whatever proxies and load balancers sit between it and the public internet). \n/** @type {import('@sveltejs/kit').HandleFetch} */\nexport async function handleFetch({ request, fetch }) {\n\tif (request.url.startsWith('https://api.yourapp.com/')) {\n\t\t// clone the original request, but change the URL\n\t\trequest = new Request(\n\t\t\trequest.url.replace('https://api.yourapp.com/', 'http://localhost:9999/'),\n\t\t\trequest\n\t\t);\n\t}\n\n\treturn fetch(request);\n}CredentialsFor same-origin requests, SvelteKit's fetch implementation will forward cookie and authorization headers unless the credentials option is set to &quot;omit&quot;.For cross-origin requests, cookie will be included if the request URL belongs to a subdomain of the app — for example if your app is on my-domain.com, and your API is on api.my-domain.com, cookies will be included in the request.If your app and your API are on sibling subdomains — www.my-domain.com and api.my-domain.com for example — then a cookie belonging to a common parent domain like my-domain.com will not be included, because SvelteKit has no way to know which domain the cookie belongs to. In these cases you will need to manually include the cookie using handleFetch: \n \n/** @type {import('@sveltejs/kit').HandleFetch} */\nexport async function handleFetch({ event, request, fetch }) {\n\tif (request.url.startsWith('https://api.my-domain.com/')) {\n\t\trequest.headers.set('cookie', event.request.headers.get('cookie'));\n\t}\n\n\treturn fetch(request);\n}"
          },
          {
            "title": "Hooks > Shared hooks",
            "content": "The following can be added to src/hooks.server.js and src/hooks.client.js:"
          },
          {
            "title": "Hooks > Shared hooks > handleError",
            "content": "If an unexpected error is thrown during loading or rendering, this function will be called with the error, event, status code and message. This allows for two things:undefined\nFor errors thrown from your code (or library code called by your code) the status will be 500 and the message will be &quot;Internal Error&quot;. While error.message may contain sensitive information that should not be exposed to users, message is safe (albeit meaningless to the average user).To add more information to the $page.error object in a type-safe way, you can customize the expected shape by declaring an App.Error interface (which must include message: string, to guarantee sensible fallback behavior). This allows you to — for example — append a tracking ID for users to quote in correspondence with your technical support staff: \ndeclare global {\n\tnamespace App {\n\t\tinterface Error {\n\t\t\tmessage: string;\n\t\t\terrorId: string;\n\t\t}\n\t}\n}\n\nexport {};import * as Sentry from '@sentry/sveltekit';\n\nSentry.init({/*...*/})\n\n/** @type {import('@sveltejs/kit').HandleServerError} */\nexport async function handleError({ error, event, status, message }) {\n\tconst errorId = crypto.randomUUID();\n\n\t// example integration with https://sentry.io/\n\tSentry.captureException(error, {\n\t\textra: { event, errorId, status }\n\t});\n\n\treturn {\n\t\tmessage: 'Whoops!',\n\t\terrorId\n\t};\n}import * as Sentry from '@sentry/sveltekit';\n\nSentry.init({/*...*/})\n\n/** @type {import('@sveltejs/kit').HandleClientError} */\nexport async function handleError({ error, event, status, message }) {\n\tconst errorId = crypto.randomUUID();\n\n\t// example integration with https://sentry.io/\n\tSentry.captureException(error, {\n\t\textra: { event, errorId, status }\n\t});\n\n\treturn {\n\t\tmessage: 'Whoops!',\n\t\terrorId\n\t};\n}[!NOTE] In `src/hooks.client.js`, the type of `handleError` is `HandleClientError` instead of `HandleServerError`, and `event` is a `NavigationEvent` rather than a `RequestEvent`.\nThis function is not called for expected errors (those thrown with the `error` function imported from @sveltejs/kit).During development, if an error occurs because of a syntax error in your Svelte code, the passed in error has a frame property appended highlighting the location of the error.[!NOTE] Make sure that `handleError` _never_ throws an error"
          },
          {
            "title": "Hooks > Universal hooks",
            "content": "The following can be added to src/hooks.js. Universal hooks run on both server and client (not to be confused with shared hooks, which are environment-specific)."
          },
          {
            "title": "Hooks > Universal hooks > reroute",
            "content": "This function runs before handle and allows you to change how URLs are translated into routes. The returned pathname (which defaults to url.pathname) is used to select the route and its parameters.For example, you might have a src/routes/[[lang]]/about/+page.svelte page, which should be accessible as /en/about or /de/ueber-uns or /fr/a-propos. You could implement this with reroute: \n \n \n\n/** @type {Record<string, string>} */\nconst translated = {\n\t'/en/about': '/en/about',\n\t'/de/ueber-uns': '/de/about',\n\t'/fr/a-propos': '/fr/about',\n};\n\n/** @type {import('@sveltejs/kit').Reroute} */\nexport function reroute({ url }) {\n\tif (url.pathname in translated) {\n\t\treturn translated[url.pathname];\n\t}\n}The lang parameter will be correctly derived from the returned pathname.Using reroute will not change the contents of the browser's address bar, or the value of event.url."
          },
          {
            "title": "Hooks > Further reading",
            "content": "undefined"
          },
          {
            "title": "Errors",
            "content": "Errors are an inevitable fact of software development. SvelteKit handles errors differently depending on where they occur, what kind of errors they are, and the nature of the incoming request."
          },
          {
            "title": "Errors > Error objects",
            "content": "SvelteKit distinguishes between expected and unexpected errors, both of which are represented as simple { message: string } objects by default.You can add additional properties, like a code or a tracking id, as shown in the examples below. (When using TypeScript this requires you to redefine the Error type as described in  type safety)."
          },
          {
            "title": "Errors > Expected errors",
            "content": "An expected error is one created with the `error` helper imported from @sveltejs/kit:import { error } from '@sveltejs/kit';\nimport * as db from '$lib/server/database';\n\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ params }) {\n\tconst post = await db.getPost(params.slug);\n\n\tif (!post) {\n\t\terror(404, {\n\t\t\tmessage: 'Not found'\n\t\t});\n\t}\n\n\treturn { post };\n}This throws an exception that SvelteKit catches, causing it to set the response status code to 404 and render an `+error.svelte` component, where $page.error is the object provided as the second argument to error(...).<!--- file: src/routes/+error.svelte --->\n<script>\n\timport { page } from '$app/stores';\n</script>\n\n<h1>{$page.error.message}</h1>You can add extra properties to the error object if needed...error(404, {\n\tmessage: 'Not found',\n\t+++code: 'NOT_FOUND'+++\n});...otherwise, for convenience, you can pass a string as the second argument:---error(404, { message: 'Not found' });---\n+++error(404, 'Not found');+++[!NOTE] [In SvelteKit 1.x](migrating-to-sveltekit-2#redirect-and-error-are-no-longer-thrown-by-you) you had to `throw` the `error` yourself"
          },
          {
            "title": "Errors > Unexpected errors",
            "content": "An unexpected error is any other exception that occurs while handling a request. Since these can contain sensitive information, unexpected error messages and stack traces are not exposed to users.By default, unexpected errors are printed to the console (or, in production, your server logs), while the error that is exposed to the user has a generic shape:{ \"message\": \"Internal Error\" }Unexpected errors will go through the `handleError` hook, where you can add your own error handling — for example, sending errors to a reporting service, or returning a custom error object which becomes $page.error."
          },
          {
            "title": "Errors > Responses",
            "content": "If an error occurs inside handle or inside a `+server.js` request handler, SvelteKit will respond with either a fallback error page or a JSON representation of the error object, depending on the request's Accept headers.You can customise the fallback error page by adding a src/error.html file:<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"utf-8\" />\n\t\t<title>%sveltekit.error.message%</title>\n\t</head>\n\t<body>\n\t\t<h1>My custom error page</h1>\n\t\t<p>Status: %sveltekit.status%</p>\n\t\t<p>Message: %sveltekit.error.message%</p>\n\t</body>\n</html>SvelteKit will replace %sveltekit.status% and %sveltekit.error.message% with their corresponding values.If the error instead occurs inside a load function while rendering a page, SvelteKit will render the `+error.svelte` component nearest to where the error occurred. If the error occurs inside a load function in +layout(.server).js, the closest error boundary in the tree is an +error.svelte file above that layout (not next to it).The exception is when the error occurs inside the root +layout.js or +layout.server.js, since the root layout would ordinarily contain the +error.svelte component. In this case, SvelteKit uses the fallback error page."
          },
          {
            "title": "Errors > Type safety",
            "content": "If you're using TypeScript and need to customize the shape of errors, you can do so by declaring an App.Error interface in your app (by convention, in src/app.d.ts, though it can live anywhere that TypeScript can 'see'): \ndeclare global {\n\tnamespace App {\n\t\tinterface Error {\n+++\t\t\tcode: string;\n\t\t\tid: string;+++\n\t\t}\n\t}\n}\n\nexport {};This interface always includes a message: string property."
          },
          {
            "title": "Errors > Further reading",
            "content": "undefined"
          },
          {
            "title": "Link options",
            "content": "In SvelteKit, <a> elements (rather than framework-specific <Link> components) are used to navigate between the routes of your app. If the user clicks on a link whose href is 'owned' by the app (as opposed to, say, a link to an external site) then SvelteKit will navigate to the new page by importing its code and then calling any load functions it needs to fetch data.You can customise the behaviour of links with data-sveltekit-* attributes. These can be applied to the <a> itself, or to a parent element.These options also apply to <form> elements with `method=\"GET\"`."
          },
          {
            "title": "Link options > data-sveltekit-preload-data",
            "content": "Before the browser registers that the user has clicked on a link, we can detect that they've hovered the mouse over it (on desktop) or that a touchstart or mousedown event was triggered. In both cases, we can make an educated guess that a click event is coming.SvelteKit can use this information to get a head start on importing the code and fetching the page's data, which can give us an extra couple of hundred milliseconds — the difference between a user interface that feels laggy and one that feels snappy.We can control this behaviour with the data-sveltekit-preload-data attribute, which can have one of two values:undefined\nThe default project template has a data-sveltekit-preload-data=&quot;hover&quot; attribute applied to the <body> element in src/app.html, meaning that every link is preloaded on hover by default:<body data-sveltekit-preload-data=\"hover\">\n\t<div style=\"display: contents\">%sveltekit.body%</div>\n</body>Sometimes, calling load when the user hovers over a link might be undesirable, either because it's likely to result in false positives (a click needn't follow a hover) or because data is updating very quickly and a delay could mean staleness.In these cases, you can specify the &quot;tap&quot; value, which causes SvelteKit to call load only when the user taps or clicks on a link:<a data-sveltekit-preload-data=\"tap\" href=\"/stonks\">\n\tGet current stonk values\n</a>[!NOTE] You can also programmatically invoke `preloadData` from `$app/navigation`.\nData will never be preloaded if the user has chosen reduced data usage, meaning `navigator.connection.saveData` is true."
          },
          {
            "title": "Link options > data-sveltekit-preload-code",
            "content": "Even in cases where you don't want to preload data for a link, it can be beneficial to preload the code. The data-sveltekit-preload-code attribute works similarly to data-sveltekit-preload-data, except that it can take one of four values, in decreasing 'eagerness':undefined\nNote that viewport and eager only apply to links that are present in the DOM immediately following navigation — if a link is added later (in an {#if ...} block, for example) it will not be preloaded until triggered by hover or tap. This is to avoid performance pitfalls resulting from aggressively observing the DOM for changes.[!NOTE] Since preloading code is a prerequisite for preloading data, this attribute will only have an effect if it specifies a more eager value than any `data-sveltekit-preload-data` attribute that is present.\nAs with data-sveltekit-preload-data, this attribute will be ignored if the user has chosen reduced data usage."
          },
          {
            "title": "Link options > data-sveltekit-reload",
            "content": "Occasionally, we need to tell SvelteKit not to handle a link, but allow the browser to handle it. Adding a data-sveltekit-reload attribute to a link...<a data-sveltekit-reload href=\"/path\">Path</a>...will cause a full-page navigation when the link is clicked.Links with a rel=&quot;external&quot; attribute will receive the same treatment. In addition, they will be ignored during prerendering."
          },
          {
            "title": "Link options > data-sveltekit-replacestate",
            "content": "Sometimes you don't want navigation to create a new entry in the browser's session history. Adding a data-sveltekit-replacestate attribute to a link...<a data-sveltekit-replacestate href=\"/path\">Path</a>...will replace the current history entry rather than creating a new one with pushState when the link is clicked."
          },
          {
            "title": "Link options > data-sveltekit-keepfocus",
            "content": "Sometimes you don't want focus to be reset after navigation. For example, maybe you have a search form that submits as the user is typing, and you want to keep focus on the text input.  Adding a data-sveltekit-keepfocus attribute to it...<form data-sveltekit-keepfocus>\n\t<input type=\"text\" name=\"query\">\n</form>...will cause the currently focused element to retain focus after navigation. In general, avoid using this attribute on links, since the focused element would be the <a> tag (and not a previously focused element) and screen reader and other assistive technology users often expect focus to be moved after a navigation. You should also only use this attribute on elements that still exist after navigation. If the element no longer exists, the user's focus will be lost, making for a confusing experience for assistive technology users."
          },
          {
            "title": "Link options > data-sveltekit-noscroll",
            "content": "When navigating to internal links, SvelteKit mirrors the browser's default navigation behaviour: it will change the scroll position to 0,0 so that the user is at the very top left of the page (unless the link includes a #hash, in which case it will scroll to the element with a matching ID).In certain cases, you may wish to disable this behaviour. Adding a data-sveltekit-noscroll attribute to a link...<a href=\"path\" data-sveltekit-noscroll>Path</a>...will prevent scrolling after the link is clicked."
          },
          {
            "title": "Link options > Disabling options",
            "content": "To disable any of these options inside an element where they have been enabled, use the &quot;false&quot; value:<div data-sveltekit-preload-data>\n\t<!-- these links will be preloaded -->\n\t<a href=\"/a\">a</a>\n\t<a href=\"/b\">b</a>\n\t<a href=\"/c\">c</a>\n\n\t<div data-sveltekit-preload-data=\"false\">\n\t\t<!-- these links will NOT be preloaded -->\n\t\t<a href=\"/d\">d</a>\n\t\t<a href=\"/e\">e</a>\n\t\t<a href=\"/f\">f</a>\n\t</div>\n</div>To apply an attribute to an element conditionally, do this:<div data-sveltekit-preload-data={condition ? 'hover' : false}>"
          },
          {
            "title": "Service workers",
            "content": "Service workers act as proxy servers that handle network requests inside your app. This makes it possible to make your app work offline, but even if you don't need offline support (or can't realistically implement it because of the type of app you're building), it's often worth using service workers to speed up navigation by precaching your built JS and CSS.In SvelteKit, if you have a src/service-worker.js file (or src/service-worker/index.js) it will be bundled and automatically registered. You can change the location of your service worker if you need to.You can disable automatic registration if you need to register the service worker with your own logic or use another solution. The default registration looks something like this:if ('serviceWorker' in navigator) {\n\taddEventListener('load', function () {\n\t\tnavigator.serviceWorker.register('./path/to/service-worker.js');\n\t});\n}"
          },
          {
            "title": "Service workers > Inside the service worker",
            "content": "Inside the service worker you have access to the `$service-worker` module, which provides you with the paths to all static assets, build files and prerendered pages. You're also provided with an app version string, which you can use for creating a unique cache name, and the deployment's base path. If your Vite config specifies define (used for global variable replacements), this will be applied to service workers as well as your server/client builds.The following example caches the built app and any files in static eagerly, and caches all other requests as they happen. This would make each page work offline once visited. \n/// <reference types=\"@sveltejs/kit\" />\nimport { build, files, version } from '$service-worker';\n\n// Create a unique cache name for this deployment\nconst CACHE = `cache-${version}`;\n\nconst ASSETS = [\n\t...build, // the app itself\n\t...files  // everything in `static`\n];\n\nself.addEventListener('install', (event) => {\n\t// Create a new cache and add all files to it\n\tasync function addFilesToCache() {\n\t\tconst cache = await caches.open(CACHE);\n\t\tawait cache.addAll(ASSETS);\n\t}\n\n\tevent.waitUntil(addFilesToCache());\n});\n\nself.addEventListener('activate', (event) => {\n\t// Remove previous cached data from disk\n\tasync function deleteOldCaches() {\n\t\tfor (const key of await caches.keys()) {\n\t\t\tif (key !== CACHE) await caches.delete(key);\n\t\t}\n\t}\n\n\tevent.waitUntil(deleteOldCaches());\n});\n\nself.addEventListener('fetch', (event) => {\n\t// ignore POST requests etc\n\tif (event.request.method !== 'GET') return;\n\n\tasync function respond() {\n\t\tconst url = new URL(event.request.url);\n\t\tconst cache = await caches.open(CACHE);\n\n\t\t// `build`/`files` can always be served from the cache\n\t\tif (ASSETS.includes(url.pathname)) {\n\t\t\tconst response = await cache.match(url.pathname);\n\n\t\t\tif (response) {\n\t\t\t\treturn response;\n\t\t\t}\n\t\t}\n\n\t\t// for everything else, try the network first, but\n\t\t// fall back to the cache if we're offline\n\t\ttry {\n\t\t\tconst response = await fetch(event.request);\n\n\t\t\t// if we're offline, fetch can return a value that is not a Response\n\t\t\t// instead of throwing - and we can't pass this non-Response to respondWith\n\t\t\tif (!(response instanceof Response)) {\n\t\t\t\tthrow new Error('invalid response from fetch');\n\t\t\t}\n\n\t\t\tif (response.status === 200) {\n\t\t\t\tcache.put(event.request, response.clone());\n\t\t\t}\n\n\t\t\treturn response;\n\t\t} catch (err) {\n\t\t\tconst response = await cache.match(event.request);\n\n\t\t\tif (response) {\n\t\t\t\treturn response;\n\t\t\t}\n\n\t\t\t// if there's no cache, then just error out\n\t\t\t// as there is nothing we can do to respond to this request\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tevent.respondWith(respond());\n});[!NOTE] Be careful when caching! In some cases, stale data might be worse than data that's unavailable while offline. Since browsers will empty caches if they get too full, you should also be careful about caching large assets like video files."
          },
          {
            "title": "Service workers > During development",
            "content": "The service worker is bundled for production, but not during development. For that reason, only browsers that support modules in service workers will be able to use them at dev time. If you are manually registering your service worker, you will need to pass the { type: 'module' } option in development:import { dev } from '$app/environment';\n\nnavigator.serviceWorker.register('/service-worker.js', {\n\ttype: dev ? 'module' : 'classic'\n});[!NOTE] `build` and `prerendered` are empty arrays during development"
          },
          {
            "title": "Service workers > Type safety",
            "content": "Setting up proper types for service workers requires some manual setup. Inside your service-worker.js, add the following to the top of your file:/// <reference types=\"@sveltejs/kit\" />\n/// <reference no-default-lib=\"true\"/>\n/// <reference lib=\"esnext\" />\n/// <reference lib=\"webworker\" />\n\nconst sw = /** @type {ServiceWorkerGlobalScope} */ (/** @type {unknown} */ (self));/// <reference types=\"@sveltejs/kit\" />\n/// <reference no-default-lib=\"true\"/>\n/// <reference lib=\"esnext\" />\n/// <reference lib=\"webworker\" />\n\nconst sw = self as unknown as ServiceWorkerGlobalScope;This disables access to DOM typings like HTMLElement which are not available inside a service worker and instantiates the correct globals. The reassignment of self to sw allows you to type cast it in the process (there are a couple of ways to do this, but this is the easiest that requires no additional files). Use sw instead of self in the rest of the file. The reference to the SvelteKit types ensures that the $service-worker import has proper type definitions. If you import $env/static/public you either have to // @ts-ignore the import or add /// <reference types=&quot;../.svelte-kit/ambient.d.ts&quot; /> to the reference types."
          },
          {
            "title": "Service workers > Other solutions",
            "content": "SvelteKit's service worker implementation is deliberately low-level. If you need a more full-fledged but also more opinionated solution, we recommend looking at solutions like Vite PWA plugin, which uses Workbox. For more general information on service workers, we recommend the MDN web docs."
          },
          {
            "title": "Server-only modules",
            "content": "Like a good friend, SvelteKit keeps your secrets. When writing your backend and frontend in the same repository, it can be easy to accidentally import sensitive data into your front-end code (environment variables containing API keys, for example). SvelteKit provides a way to prevent this entirely: server-only modules."
          },
          {
            "title": "Server-only modules > Private environment variables",
            "content": "The `$env/static/private` and `$env/dynamic/private` modules can only be imported into modules that only run on the server, such as `hooks.server.js` or `+page.server.js`."
          },
          {
            "title": "Server-only modules > Server-only utilities",
            "content": "The `$app/server` module, which contains a read function for reading assets from the filesystem, can likewise only be imported by code that runs on the server."
          },
          {
            "title": "Server-only modules > Your modules",
            "content": "You can make your own modules server-only in two ways:undefined"
          },
          {
            "title": "Server-only modules > How it works",
            "content": "Any time you have public-facing code that imports server-only code (whether directly or indirectly)... \n \nexport const atlantisCoordinates = [/* redacted */]; \n \nexport { atlantisCoordinates } from '$lib/server/secrets.js';\n\nexport const add = (a, b) => a + b; \n<script>\n\timport { add } from './utils.js';\n</script>...SvelteKit will error:Cannot import $lib/server/secrets.js into public-facing code:\n- src/routes/+page.svelte\n\t- src/routes/utils.js\n\t\t- $lib/server/secrets.jsEven though the public-facing code — src/routes/+page.svelte — only uses the add export and not the secret atlantisCoordinates export, the secret code could end up in JavaScript that the browser downloads, and so the import chain is considered unsafe.This feature also works with dynamic imports, even interpolated ones like await import(`./${foo}.js`), with one small caveat: during development, if there are two or more dynamic imports between the public-facing code and the server-only module, the illegal import will not be detected the first time the code is loaded.[!NOTE] Unit testing frameworks like Vitest do not distinguish between server-only and public-facing code. For this reason, illegal import detection is disabled when running tests, as determined by `process.env.TEST === 'true'`."
          },
          {
            "title": "Server-only modules > Further reading",
            "content": "undefined"
          },
          {
            "title": "Snapshots",
            "content": "Ephemeral DOM state — like scroll positions on sidebars, the content of <input> elements and so on — is discarded when you navigate from one page to another.For example, if the user fills out a form but navigates away and then back before submitting, or if the user refreshes the page, the values they filled in will be lost. In cases where it's valuable to preserve that input, you can take a snapshot of DOM state, which can then be restored if the user navigates back.To do this, export a snapshot object with capture and restore methods from a +page.svelte or +layout.svelte:<!--- file: +page.svelte --->\n<script>\n\tlet comment = '';\n\n\t/** @type {import('./$types').Snapshot<string>} */\n\texport const snapshot = {\n\t\tcapture: () => comment,\n\t\trestore: (value) => comment = value\n\t};\n</script>\n\n<form method=\"POST\">\n\t<label for=\"comment\">Comment</label>\n\t<textarea id=\"comment\" bind:value={comment} />\n\t<button>Post comment</button>\n</form>When you navigate away from this page, the capture function is called immediately before the page updates, and the returned value is associated with the current entry in the browser's history stack. If you navigate back, the restore function is called with the stored value as soon as the page is updated.The data must be serializable as JSON so that it can be persisted to sessionStorage. This allows the state to be restored when the page is reloaded, or when the user navigates back from a different site.[!NOTE] Avoid returning very large objects from `capture` — once captured, objects will be retained in memory for the duration of the session, and in extreme cases may be too large to persist to `sessionStorage`."
          },
          {
            "title": "Shallow routing",
            "content": "As you navigate around a SvelteKit app, you create history entries. Clicking the back and forward buttons traverses through this list of entries, re-running any load functions and replacing page components as necessary.Sometimes, it's useful to create history entries without navigating. For example, you might want to show a modal dialog that the user can dismiss by navigating back. This is particularly valuable on mobile devices, where swipe gestures are often more natural than interacting directly with the UI. In these cases, a modal that is not associated with a history entry can be a source of frustration, as a user may swipe backwards in an attempt to dismiss it and find themselves on the wrong page.SvelteKit makes this possible with the `pushState` and `replaceState` functions, which allow you to associate state with a history entry without navigating. For example, to implement a history-driven modal:<!--- file: +page.svelte --->\n<script>\n\timport { pushState } from '$app/navigation';\n\timport { page } from '$app/stores';\n\timport Modal from './Modal.svelte';\n\n\tfunction showModal() {\n\t\tpushState('', {\n\t\t\tshowModal: true\n\t\t});\n\t}\n</script>\n\n{#if $page.state.showModal}\n\t<Modal close={() => history.back()} />\n{/if}The modal can be dismissed by navigating back (unsetting $page.state.showModal) or by interacting with it in a way that causes the close callback to run, which will navigate back programmatically."
          },
          {
            "title": "Shallow routing > API",
            "content": "The first argument to pushState is the URL, relative to the current URL. To stay on the current URL, use ''.The second argument is the new page state, which can be accessed via the page store as $page.state. You can make page state type-safe by declaring an `App.PageState` interface (usually in src/app.d.ts).To set page state without creating a new history entry, use replaceState instead of pushState."
          },
          {
            "title": "Shallow routing > Loading data for a route",
            "content": "When shallow routing, you may want to render another +page.svelte inside the current page. For example, clicking on a photo thumbnail could pop up the detail view without navigating to the photo page.For this to work, you need to load the data that the +page.svelte expects. A convenient way to do this is to use `preloadData` inside the click handler of an <a> element. If the element (or a parent) uses `data-sveltekit-preload-data`, the data will have already been requested, and preloadData will reuse that request.<!--- file: src/routes/photos/+page.svelte --->\n<script>\n\timport { preloadData, pushState, goto } from '$app/navigation';\n\timport { page } from '$app/stores';\n\timport Modal from './Modal.svelte';\n\timport PhotoPage from './[id]/+page.svelte';\n\n\texport let data;\n</script>\n\n{#each data.thumbnails as thumbnail}\n\t<a\n\t\thref=\"/photos/{thumbnail.id}\"\n\t\ton:click={async (e) => {\n\t\t\tif (innerWidth < 640        // bail if the screen is too small\n\t\t\t\t|| e.shiftKey             // or the link is opened in a new window\n\t\t\t\t|| e.metaKey || e.ctrlKey // or a new tab (mac: metaKey, win/linux: ctrlKey)\n\t\t\t\t// should also consider clicking with a mouse scroll wheel\n\t\t\t) return;\n\n\t\t\t// prevent navigation\n\t\t\te.preventDefault();\n\n\t\t\tconst { href } = e.currentTarget;\n\n\t\t\t// run `load` functions (or rather, get the result of the `load` functions\n\t\t\t// that are already running because of `data-sveltekit-preload-data`)\n\t\t\tconst result = await preloadData(href);\n\n\t\t\tif (result.type === 'loaded' && result.status === 200) {\n\t\t\t\tpushState(href, { selected: result.data });\n\t\t\t} else {\n\t\t\t\t// something bad happened! try navigating\n\t\t\t\tgoto(href);\n\t\t\t}\n\t\t}}\n\t>\n\t\t<img alt={thumbnail.alt} src={thumbnail.src} />\n\t</a>\n{/each}\n\n{#if $page.state.selected}\n\t<Modal on:close={() => history.back()}>\n\t\t<!-- pass page data to the +page.svelte component,\n\t\t     just like SvelteKit would on navigation -->\n\t\t<PhotoPage data={$page.state.selected} />\n\t</Modal>\n{/if}"
          },
          {
            "title": "Shallow routing > Caveats",
            "content": "During server-side rendering, $page.state is always an empty object. The same is true for the first page the user lands on — if the user reloads the page (or returns from another document), state will not be applied until they navigate.Shallow routing is a feature that requires JavaScript to work. Be mindful when using it and try to think of sensible fallback behavior in case JavaScript isn't available."
          },
          {
            "title": "Packaging",
            "content": "You can use SvelteKit to build apps as well as component libraries, using the @sveltejs/package package (npx sv create has an option to set this up for you).When you're creating an app, the contents of src/routes is the public-facing stuff; `src/lib` contains your app's internal library.A component library has the exact same structure as a SvelteKit app, except that src/lib is the public-facing bit, and your root package.json is used to publish the package. src/routes might be a documentation or demo site that accompanies the library, or it might just be a sandbox you use during development.Running the svelte-package command from @sveltejs/package will take the contents of src/lib and generate a dist directory (which can be configured) containing the following:undefined\n[!NOTE] `@sveltejs/package` version 1 generated a `package.json`. This is no longer the case and it will now use the `package.json` from your project and validate that it is correct instead. If you're still on version 1, see [this PR](https://github.com/sveltejs/kit/pull/8922) for migration instructions."
          },
          {
            "title": "Packaging > Anatomy of a package.json",
            "content": "Since you're now building a library for public use, the contents of your package.json will become more important. Through it, you configure the entry points of your package, which files are published to npm, and which dependencies your library has. Let's go through the most important fields one by one."
          },
          {
            "title": "Packaging > Anatomy of a package.json > name",
            "content": "This is the name of your package. It will be available for others to install using that name, and visible on https://npmjs.com/package/<name>.{\n\t\"name\": \"your-library\"\n}Read more about it here."
          },
          {
            "title": "Packaging > Anatomy of a package.json > license",
            "content": "Every package should have a license field so people know how they are allowed to use it. A very popular license which is also very permissive in terms of distribution and reuse without warranty is MIT.{\n\t\"license\": \"MIT\"\n}Read more about it here. Note that you should also include a LICENSE file in your package."
          },
          {
            "title": "Packaging > Anatomy of a package.json > files",
            "content": "This tells npm which files it will pack up and upload to npm. It should contain your output folder (dist by default). Your package.json and README and LICENSE will always be included, so you don't need to specify them.{\n\t\"files\": [\"dist\"]\n}To exclude unnecessary files (such as unit tests, or modules that are only imported from src/routes etc) you can add them to an .npmignore file. This will result in smaller packages that are faster to install.Read more about it here."
          },
          {
            "title": "Packaging > Anatomy of a package.json > exports",
            "content": "The &quot;exports&quot; field contains the package's entry points. If you set up a new library project through npx sv create, it's set to a single export, the package root:{\n\t\"exports\": {\n\t\t\".\": {\n\t\t\t\"types\": \"./dist/index.d.ts\",\n\t\t\t\"svelte\": \"./dist/index.js\"\n\t\t}\n\t}\n}This tells bundlers and tooling that your package only has one entry point, the root, and everything should be imported through that, like this: \nimport { Something } from 'your-library';The types and svelte keys are export conditions. They tell tooling what file to import when they look up the your-library import:undefined\n[!NOTE] Previous versions of `@sveltejs/package` also added a `package.json` export. This is no longer part of the template because all tooling can now deal with a `package.json` not being explicitly exported.\nYou can adjust exports to your liking and provide more entry points. For example, if instead of a src/lib/index.js file that re-exported components you wanted to expose a src/lib/Foo.svelte component directly, you could create the following export map...{\n\t\"exports\": {\n\t\t\"./Foo.svelte\": {\n\t\t\t\"types\": \"./dist/Foo.svelte.d.ts\",\n\t\t\t\"svelte\": \"./dist/Foo.svelte\"\n\t\t}\n\t}\n}...and a consumer of your library could import the component like so:import Foo from 'your-library/Foo.svelte';[!NOTE] Beware that doing this will need additional care if you provide type definitions. Read more about the caveat [here](#TypeScript)\nIn general, each key of the exports map is the path the user will have to use to import something from your package, and the value is the path to the file that will be imported or a map of export conditions which in turn contains these file paths.Read more about exports here."
          },
          {
            "title": "Packaging > Anatomy of a package.json > svelte",
            "content": "This is a legacy field that enabled tooling to recognise Svelte component libraries. It's no longer necessary when using the svelte export condition, but for backwards compatibility with outdated tooling that doesn't yet know about export conditions it's good to keep it around. It should point towards your root entry point.{\n\t\"svelte\": \"./dist/index.js\"\n}"
          },
          {
            "title": "Packaging > Anatomy of a package.json > sideEffects",
            "content": "The sideEffects field in package.json is used by bundlers to determine if a module may contain code that has side effects. A module is considered to have side effects if it makes changes that are observable from other scripts outside the module when it's imported. For example, side effects include modifying global variables or the prototype of built-in JavaScript objects. Because a side effect could potentially affect the behavior of other parts of the application, these files/modules will be included in the final bundle regardless of whether their exports are used in the application. It is a best practice to avoid side effects in your code.Setting the sideEffects field in package.json can help the bundler to be more aggressive in eliminating unused exports from the final bundle, a process known as tree-shaking. This results in smaller and more efficient bundles. Different bundlers handle sideEffects in various manners. While not necessary for Vite, we recommend that libraries state that all CSS files have side effects so that your library will be compatible with webpack. This is the configuration that comes with newly created projects: \n{\n\t\"sideEffects\": [\"**/*.css\"]\n}If the scripts in your library have side effects, ensure that you update the `sideEffects` field. All scripts are marked as side effect free by default in newly created projects. If a file with side effects is incorrectly marked as having no side effects, it can result in broken functionality.\nIf your package has files with side effects, you can specify them in an array: \n{\n    \"sideEffects\": [\n    \t\"**/*.css\",\n    \t\"./dist/sideEffectfulFile.js\"\n    ]\n}This will treat only the specified files as having side effects."
          },
          {
            "title": "Packaging > TypeScript",
            "content": "You should ship type definitions for your library even if you don't use TypeScript yourself so that people who do get proper intellisense when using your library. @sveltejs/package makes the process of generating types mostly opaque to you. By default, when packaging your library, type definitions are auto-generated for JavaScript, TypeScript and Svelte files. All you need to ensure is that the types condition in the exports map points to the correct files. When initialising a library project through npx sv create, this is automatically setup for the root export.If you have something else than a root export however — for example providing a your-library/foo import — you need to take additional care for providing type definitions. Unfortunately, TypeScript by default will not resolve the types condition for an export like { &quot;./foo&quot;: { &quot;types&quot;: &quot;./dist/foo.d.ts&quot;, ... }}. Instead, it will search for a foo.d.ts relative to the root of your library (i.e. your-library/foo.d.ts instead of your-library/dist/foo.d.ts). To fix this, you have two options:The first option is to require people using your library to set the moduleResolution option in their tsconfig.json (or jsconfig.json) to bundler (available since TypeScript 5, the best and recommended option in the future), node16 or nodenext. This opts TypeScript into actually looking at the exports map and resolving the types correctly.The second option is to (ab)use the typesVersions feature from TypeScript to wire up the types. This is a field inside package.json TypeScript uses to check for different type definitions depending on the TypeScript version, and also contains a path mapping feature for that. We leverage that path mapping feature to get what we want. For the mentioned foo export above, the corresponding typesVersions looks like this:{\n\t\"exports\": {\n\t\t\"./foo\": {\n\t\t\t\"types\": \"./dist/foo.d.ts\",\n\t\t\t\"svelte\": \"./dist/foo.js\"\n\t\t}\n\t},\n\t\"typesVersions\": {\n\t\t\">4.0\": {\n\t\t\t\"foo\": [\"./dist/foo.d.ts\"]\n\t\t}\n\t}\n}>4.0 tells TypeScript to check the inner map if the used TypeScript version is greater than 4 (which should in practice always be true). The inner map tells TypeScript that the typings for your-library/foo are found within ./dist/foo.d.ts, which essentially replicates the exports condition. You also have * as a wildcard at your disposal to make many type definitions at once available without repeating yourself. Note that if you opt into typesVersions you have to declare all type imports through it, including the root import (which is defined as &quot;index.d.ts&quot;: [..]).You can read more about that feature here."
          },
          {
            "title": "Packaging > Best practices",
            "content": "You should avoid using SvelteKit-specific modules like $app/environment in your packages unless you intend for them to only be consumable by other SvelteKit projects. E.g. rather than using import { browser } from '$app/environment' you could use import { BROWSER } from 'esm-env' (see esm-env docs). You may also wish to pass in things like the current URL or a navigation action as a prop rather than relying directly on $app/stores, $app/navigation, etc. Writing your app in this more generic fashion will also make it easier to setup tools for testing, UI demos and so on.Ensure that you add aliases via svelte.config.js (not vite.config.js or tsconfig.json), so that they are processed by svelte-package.You should think carefully about whether or not the changes you make to your package are a bug fix, a new feature, or a breaking change, and update the package version accordingly. Note that if you remove any paths from exports or any export conditions inside them from your existing library, that should be regarded as a breaking change.{\n\t\"exports\": {\n\t\t\".\": {\n\t\t\t\"types\": \"./dist/index.d.ts\",\n// changing `svelte` to `default` is a breaking change:\n---\t\t\t\"svelte\": \"./dist/index.js\"---\n+++\t\t\t\"default\": \"./dist/index.js\"+++\n\t\t},\n// removing this is a breaking change:\n---\t\t\"./foo\": {\n\t\t\t\"types\": \"./dist/foo.d.ts\",\n\t\t\t\"svelte\": \"./dist/foo.js\",\n\t\t\t\"default\": \"./dist/foo.js\"\n\t\t},---\n// adding this is ok:\n+++\t\t\"./bar\": {\n\t\t\t\"types\": \"./dist/bar.d.ts\",\n\t\t\t\"svelte\": \"./dist/bar.js\",\n\t\t\t\"default\": \"./dist/bar.js\"\n\t\t}+++\n\t}\n}"
          },
          {
            "title": "Packaging > Options",
            "content": "svelte-package accepts the following options:undefined"
          },
          {
            "title": "Packaging > Publishing",
            "content": "To publish the generated package:npm publish"
          },
          {
            "title": "Packaging > Caveats",
            "content": "All relative file imports need to be fully specified, adhering to Node's ESM algorithm. This means that for a file like src/lib/something/index.js, you must include the filename with the extension: \nimport { something } from './something+++/index.js+++';If you are using TypeScript, you need to import .ts files the same way, but using a .js file ending, not a .ts file ending. (This is a TypeScript design decision outside our control.) Setting &quot;moduleResolution&quot;: &quot;NodeNext&quot; in your tsconfig.json or jsconfig.json will help you with this.All files except Svelte files (preprocessed) and TypeScript files (transpiled to JavaScript) are copied across as-is."
          }
        ]
      },
      {
        "section": "Build and deploy",
        "blocks": [
          {
            "title": "Building your app",
            "content": "Building a SvelteKit app happens in two stages, which both happen when you run vite build (usually via npm run build).Firstly, Vite creates an optimized production build of your server code, your browser code, and your service worker (if you have one). Prerendering is executed at this stage, if appropriate.Secondly, an adapter takes this production build and tunes it for your target environment — more on this on the following pages."
          },
          {
            "title": "Building your app > During the build",
            "content": "SvelteKit will load your +page/layout(.server).js files (and all files they import) for analysis during the build. Any code that should not be executed at this stage must check that building from `$app/environment` is false:+++import { building } from '$app/environment';+++\nimport { setupMyDatabase } from '$lib/server/database';\n\n+++if (!building) {+++\n\tsetupMyDatabase();\n+++}+++\n\nexport function load() {\n\t// ...\n}"
          },
          {
            "title": "Building your app > Preview your app",
            "content": "After building, you can view your production build locally with vite preview (via npm run preview). Note that this will run the app in Node, and so is not a perfect reproduction of your deployed app — adapter-specific adjustments like the `platform` object do not apply to previews."
          },
          {
            "title": "Adapters",
            "content": "Before you can deploy your SvelteKit app, you need to adapt it for your deployment target. Adapters are small plugins that take the built app as input and generate output for deployment.Official adapters exist for a variety of platforms — these are documented on the following pages:undefined\nAdditional community-provided adapters exist for other platforms."
          },
          {
            "title": "Adapters > Using adapters",
            "content": "Your adapter is specified in svelte.config.js:import adapter from 'svelte-adapter-foo';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// adapter options go here\n\t\t})\n\t}\n};\n\nexport default config;"
          },
          {
            "title": "Adapters > Platform-specific context",
            "content": "Some adapters may have access to additional information about the request. For example, Cloudflare Workers can access an env object containing KV namespaces etc. This can be passed to the RequestEvent used in hooks and server routes as the platform property — consult each adapter's documentation to learn more."
          },
          {
            "title": "Zero-config deployments",
            "content": "When you create a new SvelteKit project with npx sv create, it installs `adapter-auto` by default. This adapter automatically installs and uses the correct adapter for supported environments when you deploy:undefined\nIt's recommended to install the appropriate adapter to your devDependencies once you've settled on a target environment, since this will add the adapter to your lockfile and slightly improve install times on CI."
          },
          {
            "title": "Zero-config deployments > Environment-specific configuration",
            "content": "To add configuration options, such as { edge: true } in `adapter-vercel` and `adapter-netlify`, you must install the underlying adapter — adapter-auto does not take any options."
          },
          {
            "title": "Zero-config deployments > Adding community adapters",
            "content": "You can add zero-config support for additional adapters by editing adapters.js and opening a pull request."
          },
          {
            "title": "Node servers",
            "content": "To generate a standalone Node server, use `adapter-node`."
          },
          {
            "title": "Node servers > Usage",
            "content": "Install with npm i -D @sveltejs/adapter-node, then add the adapter to your svelte.config.js: \n \nimport adapter from '@sveltejs/adapter-node';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};"
          },
          {
            "title": "Node servers > Deploying",
            "content": "First, build your app with npm run build. This will create the production server in the output directory specified in the adapter options, defaulting to build.You will need the output directory, the project's package.json, and the production dependencies in node_modules to run the application. Production dependencies can be generated by copying the package.json and package-lock.json and then running npm ci --omit dev (you can skip this step if your app doesn't have any dependencies). You can then start your app with this command:node buildDevelopment dependencies will be bundled into your app using Rollup. To control whether a given package is bundled or externalised, place it in devDependencies or dependencies respectively in your package.json."
          },
          {
            "title": "Node servers > Deploying > Compressing responses",
            "content": "You will typically want to compress responses coming from the server. If you are already deploying your server behind a reverse proxy for SSL or load balancing, it typically results in better performance to also handle compression at that layer since Node.js is single-threaded.However, if you're building a custom server and do want to add a compression middleware there, note that we would recommend using `@polka/compression` since SvelteKit streams responses and the more popular compression package does not support streaming and may cause errors when used."
          },
          {
            "title": "Node servers > Environment variables",
            "content": "In dev and preview, SvelteKit will read environment variables from your .env file (or .env.local, or .env.[mode], as determined by Vite.)In production, .env files are not automatically loaded. To do so, install dotenv in your project...npm install dotenv...and invoke it before running the built app:node +++-r dotenv/config+++ buildIf you use Node.js v20.6+, you can use the `--env-file` flag instead:node +++--env-file=.env+++ build"
          },
          {
            "title": "Node servers > Environment variables > PORT, HOST and SOCKET_PATH",
            "content": "By default, the server will accept connections on 0.0.0.0 using port 3000. These can be customised with the PORT and HOST environment variables:HOST=127.0.0.1 PORT=4000 node buildAlternatively, the server can be configured to accept connections on a specified socket path. When this is done using the SOCKET_PATH environment variable, the HOST and PORT environment variables will be disregarded.SOCKET_PATH=/tmp/socket node build"
          },
          {
            "title": "Node servers > Environment variables > ORIGIN, PROTOCOLHEADER, HOSTHEADER, and PORT_HEADER",
            "content": "HTTP doesn't give SvelteKit a reliable way to know the URL that is currently being requested. The simplest way to tell SvelteKit where the app is being served is to set the ORIGIN environment variable:ORIGIN=https://my.site node build\n\n# or e.g. for local previewing and testing\nORIGIN=http://localhost:3000 node buildWith this, a request for the /stuff pathname will correctly resolve to https://my.site/stuff. Alternatively, you can specify headers that tell SvelteKit about the request protocol and host, from which it can construct the origin URL:PROTOCOL_HEADER=x-forwarded-proto HOST_HEADER=x-forwarded-host node build[!NOTE] [`x-forwarded-proto`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto) and [`x-forwarded-host`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host) are de facto standard headers that forward the original protocol and host if you're using a reverse proxy (think load balancers and CDNs). You should only set these variables if your server is behind a trusted reverse proxy; otherwise, it'd be possible for clients to spoof these headers.\n\nIf you're hosting your proxy on a non-standard port and your reverse proxy supports `x-forwarded-port`, you can also set `PORT_HEADER=x-forwarded-port`.\nIf adapter-node can't correctly determine the URL of your deployment, you may experience this error when using form actions:[!NOTE] Cross-site POST form submissions are forbidden"
          },
          {
            "title": "Node servers > Environment variables > ADDRESSHEADER and XFFDEPTH",
            "content": "The RequestEvent object passed to hooks and endpoints includes an event.getClientAddress() function that returns the client's IP address. By default this is the connecting remoteAddress. If your server is behind one or more proxies (such as a load balancer), this value will contain the innermost proxy's IP address rather than the client's, so we need to specify an ADDRESS_HEADER to read the address from:ADDRESS_HEADER=True-Client-IP node build[!NOTE] Headers can easily be spoofed. As with `PROTOCOL_HEADER` and `HOST_HEADER`, you should [know what you're doing](https://adam-p.ca/blog/2022/03/x-forwarded-for/) before setting these.\nIf the ADDRESS_HEADER is X-Forwarded-For, the header value will contain a comma-separated list of IP addresses. The XFF_DEPTH environment variable should specify how many trusted proxies sit in front of your server. E.g. if there are three trusted proxies, proxy 3 will forward the addresses of the original connection and the first two proxies:<client address>, <proxy 1 address>, <proxy 2 address>Some guides will tell you to read the left-most address, but this leaves you vulnerable to spoofing:<spoofed address>, <client address>, <proxy 1 address>, <proxy 2 address>We instead read from the right, accounting for the number of trusted proxies. In this case, we would use XFF_DEPTH=3.[!NOTE] If you need to read the left-most address instead (and don't care about spoofing) — for example, to offer a geolocation service, where it's more important for the IP address to be _real_ than _trusted_, you can do so by inspecting the `x-forwarded-for` header within your app."
          },
          {
            "title": "Node servers > Environment variables > BODYSIZELIMIT",
            "content": "The maximum request body size to accept in bytes including while streaming. The body size can also be specified with a unit suffix for kilobytes (K), megabytes (M), or gigabytes (G). For example, 512K or 1M. Defaults to 512kb. You can disable this option with a value of Infinity (0 in older versions of the adapter) and implement a custom check in `handle` if you need something more advanced."
          },
          {
            "title": "Node servers > Environment variables > SHUTDOWN_TIMEOUT",
            "content": "The number of seconds to wait before forcefully closing any remaining connections after receiving a SIGTERM or SIGINT signal. Defaults to 30. Internally the adapter calls `closeAllConnections`. See Graceful shutdown for more details."
          },
          {
            "title": "Node servers > Environment variables > IDLE_TIMEOUT",
            "content": "When using systemd socket activation, IDLE_TIMEOUT specifies the number of seconds after which the app is automatically put to sleep when receiving no requests. If not set, the app runs continuously. See Socket activation for more details."
          },
          {
            "title": "Node servers > Options",
            "content": "The adapter can be configured with various options: \n \nimport adapter from '@sveltejs/adapter-node';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// default options are shown\n\t\t\tout: 'build',\n\t\t\tprecompress: true,\n\t\t\tenvPrefix: ''\n\t\t})\n\t}\n};"
          },
          {
            "title": "Node servers > Options > out",
            "content": "The directory to build the server to. It defaults to build — i.e. node build would start the server locally after it has been created."
          },
          {
            "title": "Node servers > Options > precompress",
            "content": "Enables precompressing using gzip and brotli for assets and prerendered pages. It defaults to true."
          },
          {
            "title": "Node servers > Options > envPrefix",
            "content": "If you need to change the name of the environment variables used to configure the deployment (for example, to deconflict with environment variables you don't control), you can specify a prefix:envPrefix: 'MY_CUSTOM_';MY_CUSTOM_HOST=127.0.0.1 \\\nMY_CUSTOM_PORT=4000 \\\nMY_CUSTOM_ORIGIN=https://my.site \\\nnode build"
          },
          {
            "title": "Node servers > Graceful shutdown",
            "content": "By default adapter-node gracefully shuts down the HTTP server when a SIGTERM or SIGINT signal is received. It will:undefined\n[!NOTE] If you want to customize this behaviour you can use a [custom server](#Custom-server).\nYou can listen to the sveltekit:shutdown event which is emitted after the HTTP server has closed all connections. Unlike Node's exit event, the sveltekit:shutdown event supports asynchronous operations and is always emitted when all connections are closed even if the server has dangling work such as open database connections. \nprocess.on('sveltekit:shutdown', async (reason) => {\n  await jobs.stop();\n  await db.close();\n});The parameter reason has one of the following values:undefined"
          },
          {
            "title": "Node servers > Socket activation",
            "content": "Most Linux operating systems today use a modern process manager called systemd to start the server and run and manage services. You can configure your server to allocate a socket and start and scale your app on demand. This is called socket activation. In this case, the OS will pass two environment variables to your app — LISTEN_PID and LISTEN_FDS. The adapter will then listen on file descriptor 3 which refers to a systemd socket unit that you will have to create.[!NOTE] You can still use [`envPrefix`](#Options-envPrefix) with systemd socket activation. `LISTEN_PID` and `LISTEN_FDS` are always read without a prefix.\nTo take advantage of socket activation follow these steps.undefined\n \n[Service]\nEnvironment=NODE_ENV=production IDLE_TIMEOUT=60\nExecStart=/usr/bin/node /usr/bin/myapp/buildundefined\n \n[Socket]\nListenStream=3000\n\n[Install]\nWantedBy=sockets.targetundefined"
          },
          {
            "title": "Node servers > Custom server",
            "content": "The adapter creates two files in your build directory — index.js and handler.js. Running index.js — e.g. node build, if you use the default build directory — will start a server on the configured port.Alternatively, you can import the handler.js file, which exports a handler suitable for use with Express, Connect or Polka (or even just the built-in `http.createServer`) and set up your own server: \n \nimport { handler } from './build/handler.js';\nimport express from 'express';\n\nconst app = express();\n\n// add a route that lives separately from the SvelteKit app\napp.get('/healthcheck', (req, res) => {\n\tres.end('ok');\n});\n\n// let SvelteKit handle everything else, including serving prerendered pages and static assets\napp.use(handler);\n\napp.listen(3000, () => {\n\tconsole.log('listening on port 3000');\n});"
          },
          {
            "title": "Static site generation",
            "content": "To use SvelteKit as a static site generator (SSG), use `adapter-static`.This will prerender your entire site as a collection of static files. If you'd like to prerender only some pages and dynamically server-render others, you will need to use a different adapter together with the `prerender` option."
          },
          {
            "title": "Static site generation > Usage",
            "content": "Install with npm i -D @sveltejs/adapter-static, then add the adapter to your svelte.config.js: \n \nimport adapter from '@sveltejs/adapter-static';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// default options are shown. On some platforms\n\t\t\t// these options are set automatically — see below\n\t\t\tpages: 'build',\n\t\t\tassets: 'build',\n\t\t\tfallback: undefined,\n\t\t\tprecompress: false,\n\t\t\tstrict: true\n\t\t})\n\t}\n};...and add the `prerender` option to your root layout: \n// This can be false if you're using a fallback (i.e. SPA mode)\nexport const prerender = true;[!NOTE] You must ensure SvelteKit's [`trailingSlash`](page-options#trailingSlash) option is set appropriately for your environment. If your host does not render `/a.html` upon receiving a request for `/a` then you will need to set `trailingSlash: 'always'` in your root layout to create `/a/index.html` instead."
          },
          {
            "title": "Static site generation > Zero-config support",
            "content": "Some platforms have zero-config support (more to come in future):undefined\nOn these platforms, you should omit the adapter options so that adapter-static can provide the optimal configuration: \n \nexport default {\n\tkit: {\n\t\tadapter: adapter(---{...}---)\n\t}\n};"
          },
          {
            "title": "Static site generation > Options > pages",
            "content": "The directory to write prerendered pages to. It defaults to build."
          },
          {
            "title": "Static site generation > Options > assets",
            "content": "The directory to write static assets (the contents of static, plus client-side JS and CSS generated by SvelteKit) to. Ordinarily this should be the same as pages, and it will default to whatever the value of pages is, but in rare circumstances you might need to output pages and assets to separate locations."
          },
          {
            "title": "Static site generation > Options > fallback",
            "content": "Specify a fallback page for SPA mode, e.g. index.html or 200.html or 404.html."
          },
          {
            "title": "Static site generation > Options > precompress",
            "content": "If true, precompresses files with brotli and gzip. This will generate .br and .gz files."
          },
          {
            "title": "Static site generation > Options > strict",
            "content": "By default, adapter-static checks that either all pages and endpoints (if any) of your app were prerendered, or you have the fallback option set. This check exists to prevent you from accidentally publishing an app where some parts of it are not accessible, because they are not contained in the final output. If you know this is ok (for example when a certain page only exists conditionally), you can set strict to false to turn off this check."
          },
          {
            "title": "Static site generation > GitHub Pages",
            "content": "When building for GitHub Pages, if your repo name is not equivalent to your-username.github.io, make sure to update `config.kit.paths.base` to match your repo name. This is because the site will be served from https://your-username.github.io/your-repo-name rather than from the root.You'll also want to generate a fallback 404.html page to replace the default 404 page shown by GitHub Pages.A config for GitHub Pages might look like the following: \n \nimport adapter from '@sveltejs/adapter-static';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\tfallback: '404.html'\n\t\t}),\n\t\tpaths: {\n\t\t\tbase: process.argv.includes('dev') ? '' : process.env.BASE_PATH\n\t\t}\n\t}\n};\n\nexport default config;You can use GitHub actions to automatically deploy your site to GitHub Pages when you make a change. Here's an example workflow:#"
          },
          {
            "title": "Static site generation > GitHub Pages > file: .github/workflows/deploy.yml",
            "content": "name: Deploy to GitHub Pageson:\n  push:\n    branches: 'main'jobs:\n  build_site:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4  # If you're using pnpm, add this step then change the commands and cache key below to use `pnpm`\n  # - name: Install pnpm\n  #   uses: pnpm/action-setup@v3\n  #   with:\n  #     version: 8\n\n  - name: Install Node.js\n    uses: actions/setup-node@v4\n    with:\n      node-version: 20\n      cache: npm\n\n  - name: Install dependencies\n    run: npm install\n\n  - name: build\n    env:\n      BASE_PATH: '/${{ github.event.repository.name }}'\n    run: |\n      npm run build\n\n  - name: Upload Artifacts\n    uses: actions/upload-pages-artifact@v3\n    with:\n      # this should match the `pages` option in your adapter-static options\n      path: 'build/'  deploy:\n    needs: build_site\n    runs-on: ubuntu-latestpermissions:\n  pages: write\n  id-token: write\n\nenvironment:\n  name: github-pages\n  url: ${{ steps.deployment.outputs.page_url }}\n\nsteps:\n  - name: Deploy\n    id: deployment\n    uses: actions/deploy-pages@v4\nIf you're not using GitHub actions to deploy your site (for example, you're pushing the built site to its own repo), add an empty `.nojekyll` file in your `static` directory to prevent Jekyll from interfering."
          },
          {
            "title": "Single-page apps",
            "content": "You can turn any SvelteKit app, using any adapter, into a fully client-rendered single-page app (SPA) by disabling SSR at the root layout: \nexport const ssr = false;[!NOTE] In most situations this is not recommended: it harms SEO, tends to slow down perceived performance, and makes your app inaccessible to users if JavaScript fails or is disabled (which happens [more often than you probably think](https://kryogenix.org/code/browser/everyonehasjs.html)).\nIf you don't have any server-side logic (i.e. +page.server.js, +layout.server.js or +server.js files) you can use `adapter-static` to create your SPA by adding a fallback page."
          },
          {
            "title": "Single-page apps > Usage",
            "content": "Install with npm i -D @sveltejs/adapter-static, then add the adapter to your svelte.config.js with the following options: \n \nimport adapter from '@sveltejs/adapter-static';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\tfallback: '200.html' // may differ from host to host\n\t\t})\n\t}\n};The fallback page is an HTML page created by SvelteKit from your page template (e.g. app.html) that loads your app and navigates to the correct route. For example Surge, a static web host, lets you add a 200.html file that will handle any requests that don't correspond to static assets or prerendered pages.On some hosts it may be index.html or something else entirely — consult your platform's documentation.[!NOTE] Note that the fallback page will always contain absolute asset paths (i.e. beginning with `/` rather than `.`) regardless of the value of [`paths.relative`](configuration#paths), since it is used to respond to requests for arbitrary paths."
          },
          {
            "title": "Single-page apps > Apache",
            "content": "To run an SPA on Apache, you should add a static/.htaccess file to route requests to the fallback page:<IfModule mod_rewrite.c>\n\tRewriteEngine On\n\tRewriteBase /\n\tRewriteRule ^200\\.html$ - [L]\n\tRewriteCond %{REQUEST_FILENAME} !-f\n\tRewriteCond %{REQUEST_FILENAME} !-d\n\tRewriteRule . /200.html [L]\n</IfModule>"
          },
          {
            "title": "Single-page apps > Prerendering individual pages",
            "content": "If you want certain pages to be prerendered, you can re-enable ssr alongside prerender for just those parts of your app: \nexport const prerender = true;\nexport const ssr = true;"
          },
          {
            "title": "Cloudflare Pages",
            "content": "To deploy to Cloudflare Pages, use `adapter-cloudflare`.This adapter will be installed by default when you use `adapter-auto`. If you plan on staying with Cloudflare Pages, you can switch from `adapter-auto` to using this adapter directly so that values specific to Cloudflare Workers are emulated during local development, type declarations are automatically applied, and the ability to set Cloudflare-specific options is provided."
          },
          {
            "title": "Cloudflare Pages > Comparisons",
            "content": "undefined"
          },
          {
            "title": "Cloudflare Pages > Usage",
            "content": "Install with npm i -D @sveltejs/adapter-cloudflare, then add the adapter to your svelte.config.js: \n \nimport adapter from '@sveltejs/adapter-cloudflare';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// See below for an explanation of these options\n\t\t\troutes: {\n\t\t\t\tinclude: ['/*'],\n\t\t\t\texclude: ['<all>']\n\t\t\t},\n\t\t\tplatformProxy: {\n\t\t\t\tconfigPath: 'wrangler.toml',\n\t\t\t\tenvironment: undefined,\n\t\t\t\texperimentalJsonConfig: false,\n\t\t\t\tpersist: false\n\t\t\t}\n\t\t})\n\t}\n};"
          },
          {
            "title": "Cloudflare Pages > Options > routes",
            "content": "Allows you to customise the `_routes.json` file generated by adapter-cloudflare.undefined\nYou can have up to 100 include and exclude rules combined. Generally you can omit the routes options, but if (for example) your <prerendered> paths exceed that limit, you may find it helpful to manually create an exclude list that includes '/articles/*' instead of the auto-generated ['/articles/foo', '/articles/bar', '/articles/baz', ...]."
          },
          {
            "title": "Cloudflare Pages > Options > platformProxy",
            "content": "Preferences for the emulated platform.env local bindings. See the getPlatformProxy Wrangler API documentation for a full list of options."
          },
          {
            "title": "Cloudflare Pages > Deployment",
            "content": "Please follow the Get Started Guide for Cloudflare Pages to begin.When configuring your project settings, you must use the following settings:undefined"
          },
          {
            "title": "Cloudflare Pages > Runtime APIs",
            "content": "The `env` object contains your project's bindings, which consist of KV/DO namespaces, etc. It is passed to SvelteKit via the platform property, along with `context`, `caches`, and `cf`, meaning that you can access it in hooks and endpoints: \nexport async function POST({ request, platform }) {\n\tconst x = platform.env.YOUR_DURABLE_OBJECT_NAMESPACE.idFromName('x');\n}[!NOTE] SvelteKit's built-in `$env` module should be preferred for environment variables.\nTo include type declarations for your bindings, reference them in your src/app.d.ts: \ndeclare global {\n\tnamespace App {\n\t\tinterface Platform {\n+++\t\t\tenv?: {\n\t\t\t\tYOUR_KV_NAMESPACE: KVNamespace;\n\t\t\t\tYOUR_DURABLE_OBJECT_NAMESPACE: DurableObjectNamespace;\n\t\t\t};+++\n\t\t}\n\t}\n}\n\nexport {};"
          },
          {
            "title": "Cloudflare Pages > Runtime APIs > Testing Locally",
            "content": "Cloudflare Workers specific values in the platform property are emulated during dev and preview modes. Local bindings are created based on the configuration in your wrangler.toml file and are used to populate platform.env during development and preview. Use the adapter config `platformProxy` option to change your preferences for the bindings.For testing the build, you should use wrangler version 3. Once you have built your site, run wrangler pages dev .svelte-kit/cloudflare."
          },
          {
            "title": "Cloudflare Pages > Notes",
            "content": "Functions contained in the /functions directory at the project's root will not be included in the deployment, which is compiled to a single `_worker.js` file. Functions should be implemented as server endpoints in your SvelteKit app.The _headers and _redirects files specific to Cloudflare Pages can be used for static asset responses (like images) by putting them into the /static folder.However, they will have no effect on responses dynamically rendered by SvelteKit, which should return custom headers or redirect responses from server endpoints or with the `handle` hook."
          },
          {
            "title": "Cloudflare Pages > Troubleshooting > Further reading",
            "content": "You may wish to refer to Cloudflare's documentation for deploying a SvelteKit site."
          },
          {
            "title": "Cloudflare Pages > Troubleshooting > Accessing the file system",
            "content": "You can't use fs in Cloudflare Workers — you must prerender the routes in question."
          },
          {
            "title": "Cloudflare Workers",
            "content": "To deploy to Cloudflare Workers, use `adapter-cloudflare-workers`.[!NOTE] Unless you have a specific reason to use `adapter-cloudflare-workers`, it's recommended that you use `adapter-cloudflare` instead. Both adapters have equivalent functionality, but Cloudflare Pages offers features like GitHub integration with automatic builds and deploys, preview deployments, instant rollback and so on."
          },
          {
            "title": "Cloudflare Workers > Usage",
            "content": "Install with npm i -D @sveltejs/adapter-cloudflare-workers, then add the adapter to your svelte.config.js: \n \nimport adapter from '@sveltejs/adapter-cloudflare-workers';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\tconfig: 'wrangler.toml',\n\t\t\tplatformProxy: {\n\t\t\t\tconfigPath: 'wrangler.toml',\n\t\t\t\tenvironment: undefined,\n\t\t\t\texperimentalJsonConfig: false,\n\t\t\t\tpersist: false\n\t\t\t}\n\t\t})\n\t}\n};"
          },
          {
            "title": "Cloudflare Workers > Options > config",
            "content": "Path to your custom wrangler.toml config file."
          },
          {
            "title": "Cloudflare Workers > Options > platformProxy",
            "content": "Preferences for the emulated platform.env local bindings. See the getPlatformProxy Wrangler API documentation for a full list of options."
          },
          {
            "title": "Cloudflare Workers > Basic Configuration",
            "content": "This adapter expects to find a wrangler.toml file in the project root. It should look something like this: \nname = \"<your-service-name>\"\naccount_id = \"<your-account-id>\"\n\nmain = \"./.cloudflare/worker.js\"\nsite.bucket = \"./.cloudflare/public\"\n\nbuild.command = \"npm run build\"\n\ncompatibility_date = \"2021-11-12\"\nworkers_dev = true<your-service-name> can be anything. <your-account-id> can be found by logging into your Cloudflare dashboard and grabbing it from the end of the URL:https://dash.cloudflare.com/<your-account-id>[!NOTE] You should add the `.cloudflare` directory (or whichever directories you specified for `main` and `site.bucket`) to your `.gitignore`.\nYou will need to install wrangler and log in, if you haven't already:npm i -g wrangler\nwrangler loginThen, you can build your app and deploy it:wrangler deploy"
          },
          {
            "title": "Cloudflare Workers > Custom config",
            "content": "If you would like to use a config file other than wrangler.toml you can specify so using the `config` option.If you would like to enable Node.js compatibility, you can add &quot;nodejs_compat&quot; flag to wrangler.toml: \ncompatibility_flags = [ \"nodejs_compat\" ]"
          },
          {
            "title": "Cloudflare Workers > Runtime APIs",
            "content": "The `env` object contains your project's bindings, which consist of KV/DO namespaces, etc. It is passed to SvelteKit via the platform property, along with `context`, `caches`, and `cf`, meaning that you can access it in hooks and endpoints: \nexport async function POST({ request, platform }) {\n\tconst x = platform.env.YOUR_DURABLE_OBJECT_NAMESPACE.idFromName('x');\n}[!NOTE] SvelteKit's built-in `$env` module should be preferred for environment variables.\nTo include type declarations for your bindings, reference them in your src/app.d.ts: \ndeclare global {\n\tnamespace App {\n\t\tinterface Platform {\n+++\t\t\tenv?: {\n\t\t\t\tYOUR_KV_NAMESPACE: KVNamespace;\n\t\t\t\tYOUR_DURABLE_OBJECT_NAMESPACE: DurableObjectNamespace;\n\t\t\t};+++\n\t\t}\n\t}\n}\n\nexport {};"
          },
          {
            "title": "Cloudflare Workers > Runtime APIs > Testing Locally",
            "content": "Cloudflare Workers specific values in the platform property are emulated during dev and preview modes. Local bindings are created based on the configuration in your wrangler.toml file and are used to populate platform.env during development and preview. Use the adapter config `platformProxy` option to change your preferences for the bindings.For testing the build, you should use wrangler version 3. Once you have built your site, run wrangler dev."
          },
          {
            "title": "Cloudflare Workers > Troubleshooting > Worker size limits",
            "content": "When deploying to workers, the server generated by SvelteKit is bundled into a single file. Wrangler will fail to publish your worker if it exceeds the size limits after minification. You're unlikely to hit this limit usually, but some large libraries can cause this to happen. In that case, you can try to reduce the size of your worker by only importing such libraries on the client side. See the FAQ for more information."
          },
          {
            "title": "Cloudflare Workers > Troubleshooting > Accessing the file system",
            "content": "You can't use fs in Cloudflare Workers — you must prerender the routes in question."
          },
          {
            "title": "Netlify",
            "content": "To deploy to Netlify, use `adapter-netlify`.This adapter will be installed by default when you use `adapter-auto`, but adding it to your project allows you to specify Netlify-specific options."
          },
          {
            "title": "Netlify > Usage",
            "content": "Install with npm i -D @sveltejs/adapter-netlify, then add the adapter to your svelte.config.js: \n \nimport adapter from '@sveltejs/adapter-netlify';\n\nexport default {\n\tkit: {\n\t\t// default options are shown\n\t\tadapter: adapter({\n\t\t\t// if true, will create a Netlify Edge Function rather\n\t\t\t// than using standard Node-based functions\n\t\t\tedge: false,\n\n\t\t\t// if true, will split your app into multiple functions\n\t\t\t// instead of creating a single one for the entire app.\n\t\t\t// if `edge` is true, this option cannot be used\n\t\t\tsplit: false\n\t\t})\n\t}\n};Then, make sure you have a netlify.toml file in the project root. This will determine where to write static assets based on the build.publish settings, as per this sample configuration:[build]\n\tcommand = \"npm run build\"\n\tpublish = \"build\"If the netlify.toml file or the build.publish value is missing, a default value of &quot;build&quot; will be used. Note that if you have set the publish directory in the Netlify UI to something else then you will need to set it in netlify.toml too, or use the default value of &quot;build&quot;."
          },
          {
            "title": "Netlify > Usage > Node version",
            "content": "New projects will use the current Node LTS version by default. However, if you're upgrading a project you created a while ago it may be stuck on an older version. See the Netlify docs for details on manually specifying a current Node version."
          },
          {
            "title": "Netlify > Netlify Edge Functions",
            "content": "SvelteKit supports Netlify Edge Functions. If you pass the option edge: true to the adapter function, server-side rendering will happen in a Deno-based edge function that's deployed close to the site visitor. If set to false (the default), the site will deploy to Node-based Netlify Functions. \n \nimport adapter from '@sveltejs/adapter-netlify';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// will create a Netlify Edge Function using Deno-based\n\t\t\t// rather than using standard Node-based functions\n\t\t\tedge: true\n\t\t})\n\t}\n};"
          },
          {
            "title": "Netlify > Netlify alternatives to SvelteKit functionality",
            "content": "You may build your app using functionality provided directly by SvelteKit without relying on any Netlify functionality. Using the SvelteKit versions of these features will allow them to be used in dev mode, tested with integration tests, and to work with other adapters should you ever decide to switch away from Netlify. However, in some scenarios you may find it beneficial to use the Netlify versions of these features. One example would be if you're migrating an app that's already hosted on Netlify to SvelteKit."
          },
          {
            "title": "Netlify > Netlify alternatives to SvelteKit functionality > Redirect rules",
            "content": "During compilation, redirect rules are automatically appended to your _redirects file. (If it doesn't exist yet, it will be created.) That means:undefined"
          },
          {
            "title": "Netlify > Netlify alternatives to SvelteKit functionality > Netlify Forms",
            "content": "undefined"
          },
          {
            "title": "Netlify > Netlify alternatives to SvelteKit functionality > Netlify Functions",
            "content": "With this adapter, SvelteKit endpoints are hosted as Netlify Functions. Netlify function handlers have additional context, including Netlify Identity information. You can access this context via the event.platform.context field inside your hooks and +page.server or +layout.server endpoints. These are serverless functions when the edge property is false in the adapter config or edge functions when it is true. \n \nexport const load = async (event) => {\n\tconst context = event.platform.context;\n\tconsole.log(context); // shows up in your functions log in the Netlify app\n};Additionally, you can add your own Netlify functions by creating a directory for them and adding the configuration to your netlify.toml file. For example:[build]\n\tcommand = \"npm run build\"\n\tpublish = \"build\"\n\n[functions]\n\tdirectory = \"functions\""
          },
          {
            "title": "Netlify > Troubleshooting > Accessing the file system",
            "content": "You can't use fs in edge deployments.You can use it in serverless deployments, but it won't work as expected, since files are not copied from your project into your deployment. Instead, use the read function from $app/server to access your files. read does not work inside edge deployments (this may change in future).Alternatively, you can prerender the routes in question."
          },
          {
            "title": "Vercel",
            "content": "To deploy to Vercel, use `adapter-vercel`.This adapter will be installed by default when you use `adapter-auto`, but adding it to your project allows you to specify Vercel-specific options."
          },
          {
            "title": "Vercel > Usage",
            "content": "Install with npm i -D @sveltejs/adapter-vercel, then add the adapter to your svelte.config.js: \n \nimport adapter from '@sveltejs/adapter-vercel';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// see below for options that can be set here\n\t\t})\n\t}\n};"
          },
          {
            "title": "Vercel > Deployment configuration",
            "content": "To control how your routes are deployed to Vercel as functions, you can specify deployment configuration, either through the option shown above or with `export const config` inside +server.js, +page(.server).js and +layout(.server).js files.For example you could deploy some parts of your app as Edge Functions... \n/** @type {import('@sveltejs/adapter-vercel').Config} */\nexport const config = {\n\truntime: 'edge'\n};...and others as Serverless Functions (note that by specifying config inside a layout, it applies to all child pages): \n/** @type {import('@sveltejs/adapter-vercel').Config} */\nexport const config = {\n\truntime: 'nodejs18.x'\n};The following options apply to all functions:undefined\nAdditionally, the following option applies to edge functions:undefined\nAnd the following option apply to serverless functions:undefined\nIf your functions need to access data in a specific region, it's recommended that they be deployed in the same region (or close to it) for optimal performance."
          },
          {
            "title": "Vercel > Image Optimization",
            "content": "You may set the images config to control how Vercel builds your images. See the image configuration reference for full details. As an example, you may set: \n \nimport adapter from '@sveltejs/adapter-vercel';\n\nexport default {\n\tkit: {\n\t\tadapter({\n\t\t\timages: {\n\t\t\t\tsizes: [640, 828, 1200, 1920, 3840],\n\t\t\t\tformats: ['image/avif', 'image/webp'],\n\t\t\t\tminimumCacheTTL: 300,\n\t\t\t\tdomains: ['example-app.vercel.app'],\n\t\t\t}\n\t\t})\n\t}\n};"
          },
          {
            "title": "Vercel > Incremental Static Regeneration",
            "content": "Vercel supports Incremental Static Regeneration (ISR), which provides the performance and cost advantages of prerendered content with the flexibility of dynamically rendered content.To add ISR to a route, include the isr property in your config object: \nimport { BYPASS_TOKEN } from '$env/static/private';\n\nexport const config = {\n\tisr: {\n\t\t// Expiration time (in seconds) before the cached asset will be re-generated by invoking the Serverless Function.\n\t\t// Setting the value to `false` means it will never expire.\n\t\texpiration: 60,\n\n\t\t// Random token that can be provided in the URL to bypass the cached version of the asset, by requesting the asset\n\t\t// with a __prerender_bypass=<token> cookie.\n\t\t//\n\t\t// Making a `GET` or `HEAD` request with `x-prerender-revalidate: <token>` will force the asset to be re-validated.\n\t\tbypassToken: BYPASS_TOKEN,\n\n\t\t// List of valid query parameters. Other parameters (such as utm tracking codes) will be ignored,\n\t\t// ensuring that they do not result in content being regenerated unnecessarily\n\t\tallowQuery: ['search']\n\t}\n};The expiration property is required; all others are optional.Pages that are  [prerendered](page-options#prerender) will ignore ISR configuration."
          },
          {
            "title": "Vercel > Environment variables",
            "content": "Vercel makes a set of deployment-specific environment variables available. Like other environment variables, these are accessible from $env/static/private and $env/dynamic/private (sometimes — more on that later), and inaccessible from their public counterparts. To access one of these variables from the client: \n \nimport { VERCEL_COMMIT_REF } from '$env/static/private';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport function load() {\n\treturn {\n\t\tdeploymentGitBranch: VERCEL_COMMIT_REF\n\t};\n}<!--- file: +layout.svelte --->\n<script>\n\t/** @type {import('./$types').LayoutServerData} */\n\texport let data;\n</script>\n\n<p>This staging environment was deployed from {data.deploymentGitBranch}.</p>Since all of these variables are unchanged between build time and run time when building on Vercel, we recommend using $env/static/private — which will statically replace the variables, enabling optimisations like dead code elimination — rather than $env/dynamic/private."
          },
          {
            "title": "Vercel > Skew protection",
            "content": "When a new version of your app is deployed, assets belonging to the previous version may no longer be accessible. If a user is actively using your app when this happens, it can cause errors when they navigate — this is known as version skew. SvelteKit mitigates this by detecting errors resulting from version skew and causing a hard reload to get the latest version of the app, but this will cause any client-side state to be lost. (You can also proactively mitigate it by observing the `updated` store value, which tells clients when a new version has been deployed.)Skew protection is a Vercel feature that routes client requests to their original deployment. When a user visits your app, a cookie is set with the deployment ID, and any subsequent requests will be routed to that deployment for as long as skew protection is active. When they reload the page, they will get the newest deployment. (The updated store is exempted from this behaviour, and so will continue to report new deployments.) To enable it, visit the Advanced section of your project settings on Vercel.Cookie-based skew protection comes with one caveat: if a user has multiple versions of your app open in multiple tabs, requests from older versions will be routed to the newer one, meaning they will fall back to SvelteKit's built-in skew protection."
          },
          {
            "title": "Vercel > Notes > Vercel functions",
            "content": "If you have Vercel functions contained in the api directory at the project's root, any requests for /api/* will not be handled by SvelteKit. You should implement these as API routes in your SvelteKit app instead, unless you need to use a non-JavaScript language in which case you will need to ensure that you don't have any /api/* routes in your SvelteKit app."
          },
          {
            "title": "Vercel > Notes > Node version",
            "content": "Projects created before a certain date may default to using an older Node version than what SvelteKit currently requires. You can change the Node version in your project settings."
          },
          {
            "title": "Vercel > Troubleshooting > Accessing the file system",
            "content": "You can't use fs in edge functions.You can use it in serverless functions, but it won't work as expected, since files are not copied from your project into your deployment. Instead, use the read function from $app/server to access your files. read does not work inside routes deployed as edge functions (this may change in future).Alternatively, you can prerender the routes in question."
          },
          {
            "title": "Writing adapters",
            "content": "If an adapter for your preferred environment doesn't yet exist, you can build your own. We recommend looking at the source for an adapter to a platform similar to yours and copying it as a starting point.Adapter packages implement the following API, which creates an Adapter:/** @param {AdapterSpecificOptions} options */\nexport default function (options) {\n\t/** @type {import('@sveltejs/kit').Adapter} */\n\tconst adapter = {\n\t\tname: 'adapter-package-name',\n\t\tasync adapt(builder) {\n\t\t\t// adapter implementation\n\t\t},\n\t\tasync emulate() {\n\t\t\treturn {\n\t\t\t\tasync platform({ config, prerender }) {\n\t\t\t\t\t// the returned object becomes `event.platform` during dev, build and\n\t\t\t\t\t// preview. Its shape is that of `App.Platform`\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tsupports: {\n\t\t\tread: ({ config, route }) => {\n\t\t\t\t// Return `true` if the route with the given `config` can use `read`\n\t\t\t\t// from `$app/server` in production, return `false` if it can't.\n\t\t\t\t// Or throw a descriptive error describing how to configure the deployment\n\t\t\t}\n\t\t}\n\t};\n\n\treturn adapter;\n}Of these, name and adapt are required. emulate and supports are optional.Within the adapt method, there are a number of things that an adapter should do:undefined\nWhere possible, we recommend putting the adapter output under the build/ directory with any intermediate output placed under .svelte-kit/[adapter-name]."
          }
        ]
      },
      {
        "section": "Best practices",
        "blocks": [
          {
            "title": "Performance",
            "content": "Out of the box, SvelteKit does a lot of work to make your applications as performant as possible:undefined\nNevertheless, we can't (yet) eliminate all sources of slowness. To eke out maximum performance, you should be mindful of the following tips."
          },
          {
            "title": "Performance > Diagnosing issues",
            "content": "Google's PageSpeed Insights and (for more advanced analysis) WebPageTest are excellent ways to understand the performance characteristics of a site that is already deployed to the internet.Your browser also includes useful developer tools for analysing your site, whether deployed or running locally:undefined\nNote that your site running locally in dev mode will exhibit different behaviour than your production app, so you should do performance testing in preview mode after building."
          },
          {
            "title": "Performance > Diagnosing issues > Instrumenting",
            "content": "If you see in the network tab of your browser that an API call is taking a long time and you'd like to understand why, you may consider instrumenting your backend with a tool like OpenTelemetry or Server-Timing headers."
          },
          {
            "title": "Performance > Optimizing assets > Images",
            "content": "Reducing the size of image files is often one of the most impactful changes you can make to a site's performance. Svelte provides the @sveltejs/enhanced-img package, detailed on the images page, for making this easier. Additionally, Lighthouse is useful for identifying the worst offenders."
          },
          {
            "title": "Performance > Optimizing assets > Videos",
            "content": "Video files can be very large, so extra care should be taken to ensure that they're optimized:undefined"
          },
          {
            "title": "Performance > Optimizing assets > Fonts",
            "content": "SvelteKit automatically preloads critical .js and .css files when the user visits a page, but it does not preload fonts by default, since this may cause unnecessary files (such as font weights that are referenced by your CSS but not actually used on the current page) to be downloaded. Having said that, preloading fonts correctly can make a big difference to how fast your site feels. In your `handle` hook, you can call resolve with a preload filter that includes your fonts.You can reduce the size of font files by subsetting your fonts."
          },
          {
            "title": "Performance > Reducing code size > Svelte version",
            "content": "We recommend running the latest version of Svelte. Svelte 4 is smaller and faster than Svelte 3. (The Svelte 5 preview is much smaller and faster still, but we don't recommend that you upgrade to this version until it's production ready.)"
          },
          {
            "title": "Performance > Reducing code size > Packages",
            "content": "`rollup-plugin-visualizer` can be helpful for identifying which packages are contributing the most to the size of your site. You may also find opportunities to remove code by manually inspecting the build output (use build: { minify: false } in your Vite config to make the output readable, but remember to undo that before deploying your app), or via the network tab of your browser's devtools."
          },
          {
            "title": "Performance > Reducing code size > External scripts",
            "content": "Try to minimize the number of third-party scripts running in the browser. For example, instead of using JavaScript-based analytics consider using server-side implementations, such as those offered by many platforms with SvelteKit adapters including Cloudflare, Netlify, and Vercel.To run third party scripts in a web worker (which avoids blocking the main thread), use Partytown's SvelteKit integration."
          },
          {
            "title": "Performance > Reducing code size > Selective loading",
            "content": "Code imported with static import declarations will be automatically bundled with the rest of your page. If there is a piece of code you need only when some condition is met, use the dynamic import(...) form to selectively lazy-load the component."
          },
          {
            "title": "Performance > Navigation > Preloading",
            "content": "You can speed up client-side navigations by eagerly preloading the necessary code and data, using link options. This is configured by default on the <body> element when you create a new SvelteKit app."
          },
          {
            "title": "Performance > Navigation > Non-essential data",
            "content": "For slow-loading data that isn't needed immediately, the object returned from your load function can contain promises rather than the data itself. For server load functions, this will cause the data to stream in after the navigation (or initial page load)."
          },
          {
            "title": "Performance > Navigation > Preventing waterfalls",
            "content": "One of the biggest performance killers is what is referred to as a waterfall, which is a series of requests that is made sequentially. This can happen on the server or in the browser.undefined"
          },
          {
            "title": "Performance > Hosting",
            "content": "Your frontend should be located in the same data center as your backend to minimize latency. For sites with no central backend, many SvelteKit adapters support deploying to the edge, which means handling each user's requests from a nearby server. This can reduce load times significantly. Some adapters even support configuring deployment on a per-route basis. You should also consider serving images from a CDN (which are typically edge networks) — the hosts for many SvelteKit adapters will do this automatically.Ensure your host uses HTTP/2 or newer. Vite's code splitting creates numerous small files for improved cacheability, which results in excellent performance, but this does assume that your files can be loaded in parallel with HTTP/2."
          },
          {
            "title": "Performance > Further reading",
            "content": "For the most part, building a performant SvelteKit app is the same as building any performant web app. You should be able to apply information from general performance resources such as Core Web Vitals to any web experience you build."
          },
          {
            "title": "Images",
            "content": "Images can have a big impact on your app's performance. For best results, you should optimize them by doing the following:undefined\nDoing this manually is tedious. There are a variety of techniques you can use, depending on your needs and preferences."
          },
          {
            "title": "Images > Vite's built-in handling",
            "content": "Vite will automatically process imported assets for improved performance. This includes assets referenced via the CSS url() function. Hashes will be added to the filenames so that they can be cached, and assets smaller than assetsInlineLimit will be inlined. Vite's asset handling is most often used for images, but is also useful for video, audio, etc.<script>\n\timport logo from '$lib/assets/logo.png';\n</script>\n\n<img alt=\"The project logo\" src={logo} />"
          },
          {
            "title": "Images > @sveltejs/enhanced-img",
            "content": "@sveltejs/enhanced-img is a plugin offered on top of Vite's built-in asset handling. It provides plug and play image processing that serves smaller file formats like avif or webp, automatically sets the intrinsic width and height of the image to avoid layout shift, creates images of multiple sizes for various devices, and strips EXIF data for privacy. It will work in any Vite-based project including, but not limited to, SvelteKit projects.[!NOTE] As a build plugin, `@sveltejs/enhanced-img` can only optimize files located on your machine during the build process. If you have an image located elsewhere (such as a path served from your database, CMS, or backend), please read about [loading images dynamically from a CDN](#Loading-images-dynamically-from-a-CDN).\n\n**WARNING**: The `@sveltejs/enhanced-img` package is experimental. It uses pre-1.0 versioning and may introduce breaking changes with every minor version release."
          },
          {
            "title": "Images > @sveltejs/enhanced-img > Setup",
            "content": "Install:npm install --save-dev @sveltejs/enhanced-imgAdjust vite.config.js:import { sveltekit } from '@sveltejs/kit/vite';\n+++import { enhancedImages } from '@sveltejs/enhanced-img';+++\nimport { defineConfig } from 'vite';\n\nexport default defineConfig({\n\tplugins: [\n\t\t+++enhancedImages(),+++\n\t\tsveltekit()\n\t]\n});Building will take longer on the first build due to the computational expense of transforming images. However, the build output will be cached in ./node_modules/.cache/imagetools so that subsequent builds will be fast."
          },
          {
            "title": "Images > @sveltejs/enhanced-img > Basic usage",
            "content": "Use in your .svelte components by using <enhanced:img> rather than <img> and referencing the image file with a Vite asset import path:<enhanced:img src=\"./path/to/your/image.jpg\" alt=\"An alt text\" />At build time, your <enhanced:img> tag will be replaced with an <img> wrapped by a <picture> providing multiple image types and sizes. It's only possible to downscale images without losing quality, which means that you should provide the highest resolution image that you need — smaller versions will be generated for the various device types that may request an image.You should provide your image at 2x resolution for HiDPI displays (a.k.a. retina displays). <enhanced:img> will automatically take care of serving smaller versions to smaller devices.If you wish to add styles to your <enhanced:img>, you should add a class and target that."
          },
          {
            "title": "Images > @sveltejs/enhanced-img > Dynamically choosing an image",
            "content": "You can also manually import an image asset and pass it to an <enhanced:img>. This is useful when you have a collection of static images and would like to dynamically choose one or iterate over them. In this case you will need to update both the import statement and <img> element as shown below to indicate you'd like process them.<script>\n\timport MyImage from './path/to/your/image.jpg?enhanced';\n</script>\n\n<enhanced:img src={MyImage} alt=\"some alt text\" />You can also use Vite's `import.meta.glob`. Note that you will have to specify enhanced via a custom query:<script>\n\tconst imageModules = import.meta.glob(\n\t\t'/path/to/assets/*.{avif,gif,heif,jpeg,jpg,png,tiff,webp,svg}',\n\t\t{\n\t\t\teager: true,\n\t\t\tquery: {\n\t\t\t\tenhanced: true\n\t\t\t}\n\t\t}\n\t)\n</script>\n\n{#each Object.entries(imageModules) as [_path, module]}\n\t<enhanced:img src={module.default} alt=\"some alt text\" />\n{/each}"
          },
          {
            "title": "Images > @sveltejs/enhanced-img > Intrinsic Dimensions",
            "content": "width and height are optional as they can be inferred from the source image and will be automatically added when the <enhanced:img> tag is preprocessed. With these attributes, the browser can reserve the correct amount of space, preventing layout shift. If you'd like to use a different width and height you can style the image with CSS. Because the preprocessor adds a width and height for you, if you'd like one of the dimensions to be automatically calculated then you will need to specify that:<style>\n\t.hero-image img {\n\t\twidth: var(--size);\n\t\theight: auto;\n\t}\n</style>"
          },
          {
            "title": "Images > @sveltejs/enhanced-img > srcset and sizes",
            "content": "If you have a large image, such as a hero image taking the width of the design, you should specify sizes so that smaller versions are requested on smaller devices. E.g. if you have a 1280px image you may want to specify something like:<enhanced:img src=\"./image.png\" sizes=\"min(1280px, 100vw)\"/>If sizes is specified, <enhanced:img> will generate small images for smaller devices and populate the srcset attribute.The smallest picture generated automatically will have a width of 540px. If you'd like smaller images or would otherwise like to specify custom widths, you can do that with the w query parameter:<enhanced:img\n  src=\"./image.png?w=1280;640;400\"\n  sizes=\"(min-width:1920px) 1280px, (min-width:1080px) 640px, (min-width:768px) 400px\"\n/>If sizes is not provided, then a HiDPI/Retina image and a standard resolution image will be generated. The image you provide should be 2x the resolution you wish to display so that the browser can display that image on devices with a high device pixel ratio."
          },
          {
            "title": "Images > @sveltejs/enhanced-img > Per-image transforms",
            "content": "By default, enhanced images will be transformed to more efficient formats. However, you may wish to apply other transforms such as a blur, quality, flatten, or rotate operation. You can run per-image transforms by appending a query string:<enhanced:img src=\"./path/to/your/image.jpg?blur=15\" alt=\"An alt text\" />See the imagetools repo for the full list of directives."
          },
          {
            "title": "Images > Loading images dynamically from a CDN",
            "content": "In some cases, the images may not be accessible at build time — e.g. they may live inside a content management system or elsewhere.Using a content delivery network (CDN) can allow you to optimize these images dynamically, and provides more flexibility with regards to sizes, but it may involve some setup overhead and usage costs. Depending on caching strategy, the browser may not be able to use a cached copy of the asset until a 304 response is received from the CDN. Building HTML to target CDNs allows using an <img> tag since the CDN can serve the appropriate format based on the User-Agent header, whereas build-time optimizations must produce <picture> tags with multiple sources. Finally, some CDNs may generate images lazily, which could have a negative performance impact for sites with low traffic and frequently changing images.CDNs can generally be used without any need for a library. However, there are a number of libraries with Svelte support that make it easier. `@unpic/svelte` is a CDN-agnostic library with support for a large number of providers. You may also find that specific CDNs like Cloudinary have Svelte support. Finally, some content management systems (CMS) which support Svelte (such as Contentful, Storyblok, and Contentstack) have built-in support for image handling."
          },
          {
            "title": "Images > Best practices",
            "content": "undefined"
          },
          {
            "title": "Accessibility",
            "content": "SvelteKit strives to provide an accessible platform for your app by default. Svelte's compile-time accessibility checks will also apply to any SvelteKit application you build.Here's how SvelteKit's built-in accessibility features work and what you need to do to help these features to work as well as possible. Keep in mind that while SvelteKit provides an accessible foundation, you are still responsible for making sure your application code is accessible. If you're new to accessibility, see the \"further reading\" section of this guide for additional resources.We recognize that accessibility can be hard to get right. If you want to suggest improvements to how SvelteKit handles accessibility, please open a GitHub issue."
          },
          {
            "title": "Accessibility > Route announcements",
            "content": "In traditional server-rendered applications, every navigation (e.g. clicking on an <a> tag) triggers a full page reload. When this happens, screen readers and other assistive technology will read out the new page's title so that users understand that the page has changed.Since navigation between pages in SvelteKit happens without reloading the page (known as client-side routing), SvelteKit injects a live region onto the page that will read out the new page name after each navigation. This determines the page name to announce by inspecting the <title> element.Because of this behavior, every page in your app should have a unique, descriptive title. In SvelteKit, you can do this by placing a <svelte:head> element on each page:<!--- file: src/routes/+page.svelte --->\n<svelte:head>\n\t<title>Todo List</title>\n</svelte:head>This will allow screen readers and other assistive technology to identify the new page after a navigation occurs. Providing a descriptive title is also important for SEO."
          },
          {
            "title": "Accessibility > Focus management",
            "content": "In traditional server-rendered applications, every navigation will reset focus to the top of the page. This ensures that people browsing the web with a keyboard or screen reader will start interacting with the page from the beginning.To simulate this behavior during client-side routing, SvelteKit focuses the <body> element after each navigation and enhanced form submission. There is one exception - if an element with the `autofocus` attribute is present, SvelteKit will focus that element instead. Make sure to consider the implications for assistive technology when using that attribute.If you want to customize SvelteKit's focus management, you can use the afterNavigate hook:import { afterNavigate } from '$app/navigation';\n\nafterNavigate(() => {\n\t/** @type {HTMLElement | null} */\n\tconst to_focus = document.querySelector('.focus-me');\n\tto_focus?.focus();\n});You can also programmatically navigate to a different page using the `goto` function. By default, this will have the same client-side routing behavior as clicking on a link. However, goto also accepts a keepFocus option that will preserve the currently-focused element instead of resetting focus. If you enable this option, make sure the currently-focused element still exists on the page after navigation. If the element no longer exists, the user's focus will be lost, making for a confusing experience for assistive technology users."
          },
          {
            "title": "Accessibility > The \"lang\" attribute",
            "content": "By default, SvelteKit's page template sets the default language of the document to English. If your content is not in English, you should update the <html> element in src/app.html to have the correct `lang` attribute. This will ensure that any assistive technology reading the document uses the correct pronunciation. For example, if your content is in German, you should update app.html to the following: \n<html lang=\"de\">If your content is available in multiple languages, you should set the lang attribute based on the language of the current page. You can do this with SvelteKit's handle hook: \n<html lang=\"%lang%\">/** @type {import('@sveltejs/kit').Handle} */\nexport function handle({ event, resolve }) {\n\treturn resolve(event, {\n\t\ttransformPageChunk: ({ html }) => html.replace('%lang%', get_lang(event))\n\t});\n}"
          },
          {
            "title": "Accessibility > Further reading",
            "content": "For the most part, building an accessible SvelteKit app is the same as building an accessible web app. You should be able to apply information from the following general accessibility resources to any web experience you build:undefined"
          },
          {
            "title": "SEO",
            "content": "The most important aspect of SEO is to create high-quality content that is widely linked to from around the web. However, there are a few technical considerations for building sites that rank well."
          },
          {
            "title": "SEO > Out of the box > SSR",
            "content": "While search engines have got better in recent years at indexing content that was rendered with client-side JavaScript, server-side rendered content is indexed more frequently and reliably. SvelteKit employs SSR by default, and while you can disable it in `handle`, you should leave it on unless you have a good reason not to.[!NOTE] SvelteKit's rendering is highly configurable and you can implement [dynamic rendering](https://developers.google.com/search/docs/advanced/javascript/dynamic-rendering) if necessary. It's not generally recommended, since SSR has other benefits beyond SEO."
          },
          {
            "title": "SEO > Out of the box > Performance",
            "content": "Signals such as Core Web Vitals impact search engine ranking. Because Svelte and SvelteKit introduce minimal overhead, it's easier to build high performance sites. You can test your site's performance using Google's PageSpeed Insights or Lighthouse. Read the performance page for more details."
          },
          {
            "title": "SEO > Out of the box > Normalized URLs",
            "content": "SvelteKit redirects pathnames with trailing slashes to ones without (or vice versa depending on your configuration), as duplicate URLs are bad for SEO."
          },
          {
            "title": "SEO > Manual setup > &lt;title&gt; and &lt;meta&gt;",
            "content": "Every page should have well-written and unique <title> and <meta name=&quot;description&quot;> elements inside a `<svelte:head>`. Guidance on how to write descriptive titles and descriptions, along with other suggestions on making content understandable by search engines, can be found on Google's Lighthouse SEO audits documentation.[!NOTE] A common pattern is to return SEO-related `data` from page [`load`](load) functions, then use it (as [`$page.data`]($app-stores)) in a `<svelte:head>` in your root [layout](routing#layout)."
          },
          {
            "title": "SEO > Manual setup > Sitemaps",
            "content": "Sitemaps help search engines prioritize pages within your site, particularly when you have a large amount of content. You can create a sitemap dynamically using an endpoint: \nexport async function GET() {\n\treturn new Response(\n\t\t`\n\t\t<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n\t\t<urlset\n\t\t\txmlns=\"https://www.sitemaps.org/schemas/sitemap/0.9\"\n\t\t\txmlns:xhtml=\"https://www.w3.org/1999/xhtml\"\n\t\t\txmlns:mobile=\"https://www.google.com/schemas/sitemap-mobile/1.0\"\n\t\t\txmlns:news=\"https://www.google.com/schemas/sitemap-news/0.9\"\n\t\t\txmlns:image=\"https://www.google.com/schemas/sitemap-image/1.1\"\n\t\t\txmlns:video=\"https://www.google.com/schemas/sitemap-video/1.1\"\n\t\t>\n\t\t\t<!-- <url> elements go here -->\n\t\t</urlset>`.trim(),\n\t\t{\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/xml'\n\t\t\t}\n\t\t}\n\t);\n}"
          },
          {
            "title": "SEO > Manual setup > AMP",
            "content": "An unfortunate reality of modern web development is that it is sometimes necessary to create an Accelerated Mobile Pages (AMP) version of your site. In SvelteKit this can be done by setting the `inlineStyleThreshold` option... \n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\t// since <link rel=\"stylesheet\"> isn't\n\t\t// allowed, inline all styles\n\t\tinlineStyleThreshold: Infinity\n\t}\n};\n\nexport default config;...disabling csr in your root +layout.js/+layout.server.js... \nexport const csr = false;...adding amp to your app.html<html amp>\n......and transforming the HTML using transformPageChunk along with transform imported from @sveltejs/amp: \nimport * as amp from '@sveltejs/amp';\n\n/** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tlet buffer = '';\n\treturn await resolve(event, {\n\t\ttransformPageChunk: ({ html, done }) => {\n\t\t\tbuffer += html;\n\t\t\tif (done) return amp.transform(buffer);\n\t\t}\n\t});\n}To prevent shipping any unused CSS as a result of transforming the page to amp, we can use `dropcss`: \n \nimport * as amp from '@sveltejs/amp';\nimport dropcss from 'dropcss';\n\n/** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tlet buffer = '';\n\n\treturn await resolve(event, {\n\t\ttransformPageChunk: ({ html, done }) => {\n\t\t\tbuffer += html;\n\n\t\t\tif (done) {\n\t\t\t\tlet css = '';\n\t\t\t\tconst markup = amp\n\t\t\t\t\t.transform(buffer)\n\t\t\t\t\t.replace('⚡', 'amp') // dropcss can't handle this character\n\t\t\t\t\t.replace(/<style amp-custom([^>]*?)>([^]+?)<\\/style>/, (match, attributes, contents) => {\n\t\t\t\t\t\tcss = contents;\n\t\t\t\t\t\treturn `<style amp-custom${attributes}></style>`;\n\t\t\t\t\t});\n\n\t\t\t\tcss = dropcss({ css, html: markup }).css;\n\t\t\t\treturn markup.replace('</style>', `${css}</style>`);\n\t\t\t}\n\t\t}\n\t});\n}\n[!NOTE] It's a good idea to use the `handle` hook to validate the transformed HTML using `amphtml-validator`, but only if you're prerendering pages since it's very slow."
          }
        ]
      }
    ]
  },
  {
    "chapter": "Docs > Svelte",
    "sections": [
      {
        "section": "Introduction",
        "blocks": [
          {
            "title": "Overview",
            "content": "Svelte is a framework for building user interfaces on the web. It uses a compiler to turn declarative components written in HTML, CSS and JavaScript...<!--- file: App.svelte --->\n<script>\n\tfunction greet() {\n\t\talert('Welcome to Svelte!');\n\t}\n</script>\n\n<button onclick={greet}>click me</button>\n\n<style>\n\tbutton {\n\t\tfont-size: 2em;\n\t}\n</style>...into lean, tightly optimized JavaScript.You can use it to build anything on the web, from standalone components to ambitious full stack apps (using Svelte's companion application framework, SvelteKit) and everything in between.These pages serve as reference documentation. If you're new to Svelte, we recommend starting with the interactive tutorial and coming back here when you have questions.You can also try Svelte online in the playground or, if you need a more fully-featured environment, on StackBlitz."
          },
          {
            "title": "Getting started",
            "content": "We recommend using SvelteKit, the official application framework from the Svelte team powered by Vite:npx sv create myapp\ncd myapp\nnpm install\nnpm run devDon't worry if you don't know Svelte yet! You can ignore all the nice features SvelteKit brings on top for now and dive into it later.Alternatives to SvelteKit\nYou can also use Svelte directly with Vite by running npm create vite@latest and selecting the svelte option. With this, npm run build will generate HTML, JS and CSS files inside the dist directory using vite-plugin-svelte. In most cases, you will probably need to choose a routing library as well.There are also plugins for Rollup, Webpack and a few others, but we recommend Vite."
          },
          {
            "title": "Getting started > Editor tooling",
            "content": "The Svelte team maintains a VS Code extension and there are integrations with various other editors and tools as well.You can also check your code from the command line using sv check."
          },
          {
            "title": "Getting started > Getting help",
            "content": "Don't be shy about asking for help in the Discord chatroom! You can also find answers on Stack Overflow."
          },
          {
            "title": ".svelte files",
            "content": "Components are the building blocks of Svelte applications. They are written into .svelte files, using a superset of HTML.All three sections — script, styles and markup — are optional.\n \n<script module>\n\t// module-level logic goes here\n\t// (you will rarely use this)\n</script>\n\n<script>\n\t// instance-level logic goes here\n</script>\n\n<!-- markup (zero or more items) goes here -->\n\n<style>\n\t/* styles go here */\n</style>"
          },
          {
            "title": ".svelte files > <script>",
            "content": "A <script> block contains JavaScript (or TypeScript, when adding the lang=&quot;ts&quot; attribute) that runs when a component instance is created. Variables declared (or imported) at the top level can be referenced in the component's markup.In addition to normal JavaScript, you can use runes to declare component props and add reactivity to your component. Runes are covered in the next section."
          },
          {
            "title": ".svelte files > <script module>",
            "content": "A <script> tag with a module attribute runs once when the module first evaluates, rather than for each component instance. Variables declared in this block can be referenced elsewhere in the component, but not vice versa.<script module>\n\tlet total = 0;\n</script>\n\n<script>\n\ttotal += 1;\n\tconsole.log(`instantiated ${total} times`);\n</script>You can export bindings from this block, and they will become exports of the compiled module. You cannot export default, since the default export is the component itself.[!LEGACY]\nIn Svelte 4, this script tag was created using `<script context=\"module\">`"
          },
          {
            "title": ".svelte files > <style>",
            "content": "CSS inside a <style> block will be scoped to that component.<style>\n\tp {\n\t\t/* this will only affect <p> elements in this component */\n\t\tcolor: burlywood;\n\t}\n</style>For more information, head to the section on styling."
          },
          {
            "title": ".svelte.js and .svelte.ts files",
            "content": "Besides .svelte files, Svelte also operates on .svelte.js and .svelte.ts files.These behave like any other .js or .ts module, except that you can use runes. This is useful for creating reusable reactive logic, or sharing reactive state across your app.[!LEGACY]\nThis is a concept that didn't exist prior to Svelte 5"
          }
        ]
      },
      {
        "section": "Runes",
        "blocks": [
          {
            "title": "What are runes?",
            "content": "[!NOTE] **rune** /ro͞on/ _noun_\n\nA letter or mark used as a mystical or magic symbol.\nRunes are symbols that you use in .svelte and .svelte.js/.svelte.ts files to control the Svelte compiler. If you think of Svelte as a language, runes are part of the syntax — they are keywords.Runes have a $ prefix and look like functions:let message = $state('hello');They differ from normal JavaScript functions in important ways, however:undefined\n[!LEGACY]\nRunes didn't exist prior to Svelte 5."
          },
          {
            "title": "$state",
            "content": "The $state rune allows you to create reactive state, which means that your UI reacts when it changes.<script>\n\tlet count = $state(0);\n</script>\n\n<button onclick={() => count++}>\n\tclicks: {count}\n</button>Unlike other frameworks you may have encountered, there is no API for interacting with state — count is just a number, rather than an object or a function, and you can update it like you would update any other variable.Deep state\nIf $state is used with an array or a simple object, the result is a deeply reactive state proxy. Proxies allow Svelte to run code when you read or write properties, including via methods like array.push(...), triggering granular updates.[!NOTE] Classes like `Set` and `Map` will not be proxied, but Svelte provides reactive implementations for various built-ins like these that can be imported from [`svelte/reactivity`](./svelte-reactivity).\nState is proxified recursively until Svelte finds something other than an array or simple object. In a case like this...let todos = $state([\n\t{\n\t\tdone: false,\n\t\ttext: 'add more todos'\n\t}\n]);...modifying an individual todo's property will trigger updates to anything in your UI that depends on that specific property:todos[0].done = !todos[0].done;If you push a new object to the array, it will also be proxified:todos.push({\n\tdone: false,\n\ttext: 'eat lunch'\n});[!NOTE] When you update properties of proxies, the original object is _not_ mutated.\nClasses\nYou can also use $state in class fields (whether public or private): \nclass Todo {\n\tdone = $state(false);\n\ttext = $state();\n\n\tconstructor(text) {\n\t\tthis.text = text;\n\t}\n\n\treset() {\n\t\tthis.text = '';\n\t\tthis.done = false;\n\t}\n}[!NOTE] The compiler transforms `done` and `text` into `get`/`set` methods on the class prototype referencing private fields."
          },
          {
            "title": "$state > $state.raw",
            "content": "In cases where you don't want objects and arrays to be deeply reactive you can use $state.raw.State declared with $state.raw cannot be mutated; it can only be reassigned. In other words, rather than assigning to a property of an object, or using an array method like push, replace the object or array altogether if you'd like to update it:let person = $state.raw({\n\tname: 'Heraclitus',\n\tage: 49\n});\n\n// this will have no effect\nperson.age += 1;\n\n// this will work, because we're creating a new person\nperson = {\n\tname: 'Heraclitus',\n\tage: 50\n};This can improve performance with large arrays and objects that you weren't planning to mutate anyway, since it avoids the cost of making them reactive. Note that raw state can contain reactive state (for example, a raw array of reactive objects)."
          },
          {
            "title": "$state > $state.snapshot",
            "content": "To take a static snapshot of a deeply reactive $state proxy, use $state.snapshot:<script>\n\tlet counter = $state({ count: 0 });\n\n\tfunction onclick() {\n\t\t// Will log `{ count: ... }` rather than `Proxy { ... }`\n\t\tconsole.log($state.snapshot(counter));\n\t}\n</script>This is handy when you want to pass some state to an external library or API that doesn't expect a proxy, such as structuredClone."
          },
          {
            "title": "$derived",
            "content": "Derived state is declared with the $derived rune:<script>\n\tlet count = $state(0);\n\tlet doubled = $derived(count * 2);\n</script>\n\n<button onclick={() => count++}>\n\t{doubled}\n</button>\n\n<p>{count} doubled is {doubled}</p>The expression inside $derived(...) should be free of side-effects. Svelte will disallow state changes (e.g. count++) inside derived expressions.As with $state, you can mark class fields as $derived."
          },
          {
            "title": "$derived > $derived.by",
            "content": "Sometimes you need to create complex derivations that don't fit inside a short expression. In these cases, you can use $derived.by which accepts a function as its argument.<script>\n\tlet numbers = $state([1, 2, 3]);\n\tlet total = $derived.by(() => {\n\t\tlet total = 0;\n\t\tfor (const n of numbers) {\n\t\t\ttotal += n;\n\t\t}\n\t\treturn total;\n\t});\n</script>\n\n<button onclick={() => numbers.push(numbers.length + 1)}>\n\t{numbers.join(' + ')} = {total}\n</button>In essence, $derived(expression) is equivalent to $derived.by(() => expression)."
          },
          {
            "title": "$effect",
            "content": "Effects are what make your application do things. When Svelte runs an effect function, it tracks which pieces of state (and derived state) are accessed, and re-runs the function when that state later changes.Most of the effects in a Svelte app are created by Svelte itself — they're the bits that update the text in <h1>hello {name}!</h1> when name changes, for example.But you can also create your own effects with the $effect rune, which is useful when you need to synchronize an external system (whether that's a library, or a <canvas> element, or something across a network) with state inside your Svelte app.[!NOTE] Avoid overusing effects! When you do too much work in them, code often becomes difficult to understand and maintain. See [when not to use effects](#When-not-to-use-effects) to learn about alternative approaches.\nYour effects run after the component has been mounted to the DOM, and in a microtask after state changes (demo):<script>\n\tlet size = $state(50);\n\tlet color = $state('#ff3e00');\n\n\tlet canvas;\n\n\t$effect(() => {\n\t\tconst context = canvas.getContext('2d');\n\t\tcontext.clearRect(0, 0, canvas.width, canvas.height);\n\n\t\t// this will re-run whenever `color` or `size` change\n\t\tcontext.fillStyle = color;\n\t\tcontext.fillRect(0, 0, size, size);\n\t});\n</script>\n\n<canvas bind:this={canvas} width=\"100\" height=\"100\" />Re-runs are batched (i.e. changing color and size in the same moment won't cause two separate runs), and happen after any DOM updates have been applied.You can place $effect anywhere, not just at the top level of a component, as long as it is called during component initialization (or while a parent effect is active). It is then tied to the lifecycle of the component (or parent effect) and will therefore destroy itself when the component unmounts (or the parent effect is destroyed).You can return a function from $effect, which will run immediately before the effect re-runs, and before it is destroyed (demo).<script>\n\tlet count = $state(0);\n\tlet milliseconds = $state(1000);\n\n\t$effect(() => {\n\t\t// This will be recreated whenever `milliseconds` changes\n\t\tconst interval = setInterval(() => {\n\t\t\tcount += 1;\n\t\t}, milliseconds);\n\n\t\treturn () => {\n\t\t\t// if a callback is provided, it will run\n\t\t\t// a) immediately before the effect re-runs\n\t\t\t// b) when the component is destroyed\n\t\t\tclearInterval(interval);\n\t\t};\n\t});\n</script>\n\n<h1>{count}</h1>\n\n<button onclick={() => (milliseconds *= 2)}>slower</button>\n<button onclick={() => (milliseconds /= 2)}>faster</button>Understanding dependencies\n$effect automatically picks up any reactive values ($state, $derived, $props) that are synchronously read inside its function body and registers them as dependencies. When those dependencies change, the $effect schedules a rerun.Values that are read asynchronously — after an await or inside a setTimeout, for example — will not be tracked. Here, the canvas will be repainted when color changes, but not when size changes (demo):$effect(() => {\n\tconst context = canvas.getContext('2d');\n\tcontext.clearRect(0, 0, canvas.width, canvas.height);\n\n\t// this will re-run whenever `color` changes...\n\tcontext.fillStyle = color;\n\n\tsetTimeout(() => {\n\t\t// ...but not when `size` changes\n\t\tcontext.fillRect(0, 0, size, size);\n\t}, 0);\n});An effect only reruns when the object it reads changes, not when a property inside it changes. (If you want to observe changes inside an object at dev time, you can use `$inspect`.)<script>\n\tlet state = $state({ value: 0 });\n\tlet derived = $derived({ value: state.value * 2 });\n\n\t// this will run once, because `state` is never reassigned (only mutated)\n\t$effect(() => {\n\t\tstate;\n\t});\n\n\t// this will run whenever `state.value` changes...\n\t$effect(() => {\n\t\tstate.value;\n\t});\n\n\t// ...and so will this, because `derived` is a new object each time\n\t$effect(() => {\n\t\tderived;\n\t});\n</script>\n\n<button onclick={() => (state.value += 1)}>\n\t{state.value}\n</button>\n\n<p>{state.value} doubled is {derived.value}</p>An effect only depends on the values that it read the last time it ran. If a is true, changes to b will not cause this effect to rerun:$effect(() => {\n\tconsole.log('running');\n\n\tif (a || b) {\n\t\tconsole.log('inside if block');\n\t}\n});"
          },
          {
            "title": "$effect > $effect.pre",
            "content": "In rare cases, you may need to run code before the DOM updates. For this we can use the $effect.pre rune:<script>\n\timport { tick } from 'svelte';\n\n\tlet div = $state();\n\tlet messages = $state([]);\n\n\t// ...\n\n\t$effect.pre(() => {\n\t\tif (!div) return; // not yet mounted\n\n\t\t// reference `messages` array length so that this code re-runs whenever it changes\n\t\tmessages.length;\n\n\t\t// autoscroll when new messages are added\n\t\tif (div.offsetHeight + div.scrollTop > div.scrollHeight - 20) {\n\t\t\ttick().then(() => {\n\t\t\t\tdiv.scrollTo(0, div.scrollHeight);\n\t\t\t});\n\t\t}\n\t});\n</script>\n\n<div bind:this={div}>\n\t{#each messages as message}\n\t\t<p>{message}</p>\n\t{/each}\n</div>Apart from the timing, $effect.pre works exactly like $effect."
          },
          {
            "title": "$effect > $effect.tracking",
            "content": "The $effect.tracking rune is an advanced feature that tells you whether or not the code is running inside a tracking context, such as an effect or inside your template (demo):<script>\n\tconsole.log('in component setup:', $effect.tracking()); // false\n\n\t$effect(() => {\n\t\tconsole.log('in effect:', $effect.tracking()); // true\n\t});\n</script>\n\n<p>in template: {$effect.tracking()}</p> <!-- true -->This allows you to (for example) add things like subscriptions without causing memory leaks, by putting them in child effects. Here's a readable function that listens to changes from a callback function as long as it's inside a tracking context:import { tick } from 'svelte';\n\nexport default function readable<T>(\n\tinitial_value: T,\n\tstart: (callback: (update: (v: T) => T) => T) => () => void\n) {\n\tlet value = $state(initial_value);\n\n\tlet subscribers = 0;\n\tlet stop: null | (() => void) = null;\n\n\treturn {\n\t\tget value() {\n\t\t\t// If in a tracking context ...\n\t\t\tif ($effect.tracking()) {\n\t\t\t\t$effect(() => {\n\t\t\t\t\t// ...and there's no subscribers yet...\n\t\t\t\t\tif (subscribers === 0) {\n\t\t\t\t\t\t// ...invoke the function and listen to changes to update state\n\t\t\t\t\t\tstop = start((fn) => (value = fn(value)));\n\t\t\t\t\t}\n\n\t\t\t\t\tsubscribers++;\n\n\t\t\t\t\t// The return callback is called once a listener unlistens\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\ttick().then(() => {\n\t\t\t\t\t\t\tsubscribers--;\n\t\t\t\t\t\t\t// If it was the last subscriber...\n\t\t\t\t\t\t\tif (subscribers === 0) {\n\t\t\t\t\t\t\t\t// ...stop listening to changes\n\t\t\t\t\t\t\t\tstop?.();\n\t\t\t\t\t\t\t\tstop = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\t};\n}"
          },
          {
            "title": "$effect > $effect.root",
            "content": "The $effect.root rune is an advanced feature that creates a non-tracked scope that doesn't auto-cleanup. This is useful for\nnested effects that you want to manually control. This rune also allows for creation of effects outside of the component initialisation phase.<script>\n\tlet count = $state(0);\n\n\tconst cleanup = $effect.root(() => {\n\t\t$effect(() => {\n\t\t\tconsole.log(count);\n\t\t});\n\n\t\treturn () => {\n\t\t\tconsole.log('effect root cleanup');\n\t\t};\n\t});\n</script>"
          },
          {
            "title": "$effect > When not to use effects",
            "content": "In general, $effect is best considered something of an escape hatch — useful for things like analytics and direct DOM manipulation — rather than a tool you should use frequently. In particular, avoid using it to synchronise state. Instead of this...<script>\n\tlet count = $state(0);\n\tlet doubled = $state();\n\n\t// don't do this!\n\t$effect(() => {\n\t\tdoubled = count * 2;\n\t});\n</script>...do this:<script>\n\tlet count = $state(0);\n\tlet doubled = $derived(count * 2);\n</script>[!NOTE] For things that are more complicated than a simple expression like `count * 2`, you can also use `$derived.by`.\nYou might be tempted to do something convoluted with effects to link one value to another. The following example shows two inputs for &quot;money spent&quot; and &quot;money left&quot; that are connected to each other. If you update one, the other should update accordingly. Don't use effects for this (demo):<script>\n\tlet total = 100;\n\tlet spent = $state(0);\n\tlet left = $state(total);\n\n\t$effect(() => {\n\t\tleft = total - spent;\n\t});\n\n\t$effect(() => {\n\t\tspent = total - left;\n\t});\n</script>\n\n<label>\n\t<input type=\"range\" bind:value={spent} max={total} />\n\t{spent}/{total} spent\n</label>\n\n<label>\n\t<input type=\"range\" bind:value={left} max={total} />\n\t{left}/{total} left\n</label>Instead, use callbacks where possible (demo):<script>\n\tlet total = 100;\n\tlet spent = $state(0);\n\tlet left = $state(total);\n\n\tfunction updateSpent(e) {\n\t\tspent = +e.target.value;\n\t\tleft = total - spent;\n\t}\n\n\tfunction updateLeft(e) {\n\t\tleft = +e.target.value;\n\t\tspent = total - left;\n\t}\n</script>\n\n<label>\n\t<input type=\"range\" value={spent} oninput={updateSpent} max={total} />\n\t{spent}/{total} spent\n</label>\n\n<label>\n\t<input type=\"range\" value={left} oninput={updateLeft} max={total} />\n\t{left}/{total} left\n</label>If you need to use bindings, for whatever reason (for example when you want some kind of &quot;writable $derived&quot;), consider using getters and setters to synchronise state (demo):<script>\n\tlet total = 100;\n\tlet spent = $state(0);\n\n\tlet left = {\n\t\tget value() {\n\t\t\treturn total - spent;\n\t\t},\n\t\tset value(v) {\n\t\t\tspent = total - v;\n\t\t}\n\t};\n</script>\n\n<label>\n\t<input type=\"range\" bind:value={spent} max={total} />\n\t{spent}/{total} spent\n</label>\n\n<label>\n\t<input type=\"range\" bind:value={left.value} max={total} />\n\t{left.value}/{total} left\n</label>If you absolutely have to update $state within an effect and run into an infinite loop because you read and write to the same $state, use untrack."
          },
          {
            "title": "$props",
            "content": "The inputs to a component are referred to as props, which is short for properties. You pass props to components just like you pass attributes to elements:<script>\n\timport MyComponent from './MyComponent.svelte';\n</script>\n\n \n<MyComponent adjective=\"cool\" />On the other side, inside MyComponent.svelte, we can receive props with the $props rune...<script>\n\tlet props = $props();\n</script>\n\n \n<p>this component is {props.adjective}</p>...though more commonly, you'll _destructure_ your props: \n<script>\n\tlet +++{ adjective }+++ = $props();\n</script>\n\n<p>this component is {+++adjective+++}</p>"
          },
          {
            "title": "$props > Fallback values",
            "content": "Destructuring allows us to declare fallback values, which are used if the parent component does not set a given prop: \nlet { adjective = 'happy' } = $props();[!NOTE] Fallback values are not turned into reactive state proxies."
          },
          {
            "title": "$props > Renaming props",
            "content": "We can also use the destructuring assignment to rename props, which is necessary if they're invalid identifiers, or a JavaScript keyword like super:let { super: trouper = 'lights are gonna find me' } = $props();"
          },
          {
            "title": "$props > Rest props",
            "content": "Finally, we can use a rest property to get, well, the rest of the props:let { a, b, c, ...others } = $props();"
          },
          {
            "title": "$props > Updating props",
            "content": "References to a prop inside a component update when the prop itself updates — when count changes in App.svelte, it will also change inside Child.svelte. But the child component is able to temporarily override the prop value, which can be useful for unsaved ephemeral state (demo):\n \n<script>\n\timport Child from './Child.svelte';\n\n\tlet count = $state(0);\n</script>\n\n<button onclick={() => (count += 1)}>\n\tclicks (parent): {count}\n</button>\n\n<Child {count} />\n \n<script>\n\tlet { count } = $props();\n</script>\n\n<button onclick={() => (count += 1)}>\n\tclicks (child): {count}\n</button>"
          },
          {
            "title": "$props > Type safety",
            "content": "You can add type safety to your components by annotating your props, as you would with any other variable declaration. In TypeScript that might look like this...<script lang=\"ts\">\n\tlet { adjective }: { adjective: string } = $props();\n</script>...while in JSDoc you can do this:<script>\n\t/** @type {{ adjective: string }} */\n\tlet { adjective } = $props();\n</script>You can, of course, separate the type declaration from the annotation:<script lang=\"ts\">\n\tinterface Props {\n\t\tadjective: string;\n\t}\n\n\tlet { adjective }: Props = $props();\n</script>Adding types is recommended, as it ensures that people using your component can easily discover which props they should provide."
          },
          {
            "title": "$bindable",
            "content": "Ordinarily, props go one way, from parent to child. This makes it easy to understand how data flows around your app.In Svelte, component props can be bound, which means that data can also flow up from child to parent. This isn't something you should do often, but it can simplify your code if used sparingly and carefully.It also means that a state proxy can be mutated in the child.[!NOTE] Mutation is also possible with normal props, but is strongly discouraged — Svelte will warn you if it detects that a component is mutating state it does not 'own'.\nTo mark a prop as bindable, we use the $bindable rune:\n \n<script>\n\tlet { value = $bindable(), ...props } = $props();\n</script>\n\n<input bind:value={value} {...props} />\n\n<style>\n\tinput {\n\t\tfont-family: 'Comic Sans MS';\n\t\tcolor: deeppink;\n\t}\n</style>Now, a component that uses <FancyInput> can add the `bind:` directive (demo):\n/// App.svelte\n<script>\n\timport FancyInput from './FancyInput.svelte';\n\n\tlet message = $state('hello');\n</script>\n\n<FancyInput bind:value={message} />\n<p>{message}</p>The parent component doesn't have to use bind: — it can just pass a normal prop. Some parents don't want to listen to what their children have to say.In this case, you can specify a fallback value for when no prop is passed at all: \nlet { value = $bindable('fallback'), ...props } = $props();"
          },
          {
            "title": "$inspect",
            "content": "The $inspect rune is roughly equivalent to console.log, with the exception that it will re-run whenever its argument changes. $inspect tracks reactive state deeply, meaning that updating something inside an object or array using fine-grained reactivity will cause it to re-fire (demo):<script>\n\tlet count = $state(0);\n\tlet message = $state('hello');\n\n\t$inspect(count, message); // will console.log when `count` or `message` change\n</script>\n\n<button onclick={() => count++}>Increment</button>\n<input bind:value={message} />"
          },
          {
            "title": "$inspect > $inspect(...).with",
            "content": "$inspect returns a property with, which you can invoke with a callback, which will then be invoked instead of console.log. The first argument to the callback is either &quot;init&quot; or &quot;update&quot;; subsequent arguments are the values passed to $inspect (demo):<script>\n\tlet count = $state(0);\n\n\t$inspect(count).with((type, count) => {\n\t\tif (type === 'update') {\n\t\t\tdebugger; // or `console.trace`, or whatever you want\n\t\t}\n\t});\n</script>\n\n<button onclick={() => count++}>Increment</button>A convenient way to find the origin of some change is to pass console.trace to with: \n$inspect(stuff).with(console.trace);[!NOTE] `$inspect` only works during development. In a production build it becomes a noop."
          },
          {
            "title": "$host",
            "content": "When compiling a component as a custom element, the $host rune provides access to the host element, allowing you to (for example) dispatch custom events (demo):\n \n<svelte:options customElement=\"my-stepper\" />\n\n<script>\n\tfunction dispatch(type) {\n\t\t+++$host()+++.dispatchEvent(new CustomEvent(type));\n\t}\n</script>\n\n<button onclick={() => dispatch('decrement')}>decrement</button>\n<button onclick={() => dispatch('increment')}>increment</button>\n \n<script>\n\timport './Stepper.svelte';\n\n\tlet count = $state(0);\n</script>\n\n<my-stepper\n\tondecrement={() => count -= 1}\n\tonincrement={() => count += 1}\n></my-stepper>\n\n<p>count: {count}</p>"
          }
        ]
      },
      {
        "section": "Template syntax",
        "blocks": [
          {
            "title": "Basic markup",
            "content": "Markup inside a Svelte component can be thought of as HTML++."
          },
          {
            "title": "Basic markup > Tags",
            "content": "A lowercase tag, like <div>, denotes a regular HTML element. A capitalised tag or a tag that uses dot notation, such as <Widget> or <my.stuff>, indicates a component.<script>\n\timport Widget from './Widget.svelte';\n</script>\n\n<div>\n\t<Widget />\n</div>"
          },
          {
            "title": "Basic markup > Element attributes",
            "content": "By default, attributes work exactly like their HTML counterparts.<div class=\"foo\">\n\t<button disabled>can't touch this</button>\n</div>As in HTML, values may be unquoted.\n<input type=checkbox />Attribute values can contain JavaScript expressions.<a href=\"page/{p}\">page {p}</a>Or they can be JavaScript expressions.<button disabled={!clickable}>...</button>Boolean attributes are included on the element if their value is truthy and excluded if it's falsy.All other attributes are included unless their value is nullish (null or undefined).<input required={false} placeholder=\"This input field is not required\" />\n<div title={null}>This div has no title attribute</div>[!NOTE] Quoting a singular expression does not affect how the value is parsed, but in Svelte 6 it will cause the value to be coerced to a string:\n\n<!-- prettier-ignore -->\n```svelte\n<button disabled=\"{number !== 42}\">...</button>\n```\nWhen the attribute name and value match (name={name}), they can be replaced with {name}.<button {disabled}>...</button>\n<!-- equivalent to\n<button disabled={disabled}>...</button>\n-->"
          },
          {
            "title": "Basic markup > Component props",
            "content": "By convention, values passed to components are referred to as properties or props rather than attributes, which are a feature of the DOM.As with elements, name={name} can be replaced with the {name} shorthand.<Widget foo={bar} answer={42} text=\"hello\" />Spread attributes allow many attributes or properties to be passed to an element or component at once.An element or component can have multiple spread attributes, interspersed with regular ones.<Widget {...things} />"
          },
          {
            "title": "Basic markup > Events",
            "content": "Listening to DOM events is possible by adding attributes to the element that start with on. For example, to listen to the click event, add the onclick attribute to a button:<button onclick={() => console.log('clicked')}>click me</button>Event attributes are case sensitive. onclick listens to the click event, onClick listens to the Click event, which is different. This ensures you can listen to custom events that have uppercase characters in them.Because events are just attributes, the same rules as for attributes apply:undefined\nTiming-wise, event attributes always fire after events from bindings (e.g. oninput always fires after an update to bind:value). Under the hood, some event handlers are attached directly with addEventListener, while others are delegated.When using ontouchstart and ontouchmove event attributes, the handlers are passive for better performance. This greatly improves responsiveness by allowing the browser to scroll the document immediately, rather than waiting to see if the event handler calls event.preventDefault().In the very rare cases that you need to prevent these event defaults, you should use `on` instead (for example inside an action)."
          },
          {
            "title": "Basic markup > Events > Event delegation",
            "content": "To reduce memory footprint and increase performance, Svelte uses a technique called event delegation. This means that for certain events — see the list below — a single event listener at the application root takes responsibility for running any handlers on the event's path.There are a few gotchas to be aware of:undefined\nThe following event handlers are delegated:undefined"
          },
          {
            "title": "Basic markup > Text expressions",
            "content": "A JavaScript expression can be included as text by surrounding it with curly braces.{expression}Curly braces can be included in a Svelte template by using their HTML entity strings: &amp;lbrace;, &amp;lcub;, or &amp;#123; for { and &amp;rbrace;, &amp;rcub;, or &amp;#125; for }.If you're using a regular expression (RegExp) literal notation, you'll need to wrap it in parentheses.\n<h1>Hello {name}!</h1>\n<p>{a} + {b} = {a + b}.</p>\n\n<div>{(/^[A-Za-z ]+$/).test(value) ? x : y}</div>The expression will be stringified and escaped to prevent code injections. If you want to render HTML, use the {@html} tag instead.{@html potentiallyUnsafeHtmlString}[!NOTE] Make sure that you either escape the passed string or only populate it with values that are under your control in order to prevent [XSS attacks](https://owasp.org/www-community/attacks/xss/)"
          },
          {
            "title": "Basic markup > Comments",
            "content": "You can use HTML comments inside components.<!-- this is a comment! --><h1>Hello world</h1>Comments beginning with svelte-ignore disable warnings for the next block of markup. Usually, these are accessibility warnings; make sure that you're disabling them for a good reason.<!-- svelte-ignore a11y-autofocus -->\n<input bind:value={name} autofocus />You can add a special comment starting with @component that will show up when hovering over the component name in other files.<!--\n@component\n- You can use markdown here.\n- You can also use code blocks here.\n- Usage:\n  ```html\n  <Main name=\"Arethra\">\n  ```\n-->\n<script>\n\tlet { name } = $props();\n</script>\n\n<main>\n\t<h1>\n\t\tHello, {name}\n\t</h1>\n</main>"
          },
          {
            "title": "{#if ...}",
            "content": "<!--- copy: false  --->\n{#if expression}...{/if}<!--- copy: false  --->\n{#if expression}...{:else if expression}...{/if}<!--- copy: false  --->\n{#if expression}...{:else}...{/if}Content that is conditionally rendered can be wrapped in an if block.{#if answer === 42}\n\t<p>what was the question?</p>\n{/if}Additional conditions can be added with {:else if expression}, optionally ending in an {:else} clause.{#if porridge.temperature > 100}\n\t<p>too hot!</p>\n{:else if 80 > porridge.temperature}\n\t<p>too cold!</p>\n{:else}\n\t<p>just right!</p>\n{/if}(Blocks don't have to wrap elements, they can also wrap text within elements.)"
          },
          {
            "title": "{#each ...}",
            "content": "<!--- copy: false  --->\n{#each expression as name}...{/each}<!--- copy: false  --->\n{#each expression as name, index}...{/each}Iterating over values can be done with an each block. The values in question can be arrays, array-like objects (i.e. anything with a length property), or iterables like Map and Set — in other words, anything that can be used with Array.from.<h1>Shopping list</h1>\n<ul>\n\t{#each items as item}\n\t\t<li>{item.name} x {item.qty}</li>\n\t{/each}\n</ul>You can use each blocks to iterate over any array or array-like value — that is, any object with a length property.An each block can also specify an index, equivalent to the second argument in an array.map(...) callback:{#each items as item, i}\n\t<li>{i + 1}: {item.name} x {item.qty}</li>\n{/each}"
          },
          {
            "title": "{#each ...} > Keyed each blocks",
            "content": "<!--- copy: false  --->\n{#each expression as name (key)}...{/each}<!--- copy: false  --->\n{#each expression as name, index (key)}...{/each}If a key expression is provided — which must uniquely identify each list item — Svelte will use it to diff the list when data changes, rather than adding or removing items at the end. The key can be any object, but strings and numbers are recommended since they allow identity to persist when the objects themselves change.{#each items as item (item.id)}\n\t<li>{item.name} x {item.qty}</li>\n{/each}\n\n<!-- or with additional index value -->\n{#each items as item, i (item.id)}\n\t<li>{i + 1}: {item.name} x {item.qty}</li>\n{/each}You can freely use destructuring and rest patterns in each blocks.{#each items as { id, name, qty }, i (id)}\n\t<li>{i + 1}: {name} x {qty}</li>\n{/each}\n\n{#each objects as { id, ...rest }}\n\t<li><span>{id}</span><MyComponent {...rest} /></li>\n{/each}\n\n{#each items as [id, ...rest]}\n\t<li><span>{id}</span><MyComponent values={rest} /></li>\n{/each}"
          },
          {
            "title": "{#each ...} > Else blocks",
            "content": "<!--- copy: false  --->\n{#each expression as name}...{:else}...{/each}An each block can also have an {:else} clause, which is rendered if the list is empty.{#each todos as todo}\n\t<p>{todo.text}</p>\n{:else}\n\t<p>No tasks today!</p>\n{/each}"
          },
          {
            "title": "{#key ...}",
            "content": "<!--- copy: false  --->\n{#key expression}...{/key}Key blocks destroy and recreate their contents when the value of an expression changes. When used around components, this will cause them to be reinstantiated and reinitialised:{#key value}\n\t<Component />\n{/key}It's also useful if you want a transition to play whenever a value changes:{#key value}\n\t<div transition:fade>{value}</div>\n{/key}"
          },
          {
            "title": "{#await ...}",
            "content": "<!--- copy: false  --->\n{#await expression}...{:then name}...{:catch name}...{/await}<!--- copy: false  --->\n{#await expression}...{:then name}...{/await}<!--- copy: false  --->\n{#await expression then name}...{/await}<!--- copy: false  --->\n{#await expression catch name}...{/await}Await blocks allow you to branch on the three possible states of a `Promise` — pending, fulfilled or rejected.{#await promise}\n\t<!-- promise is pending -->\n\t<p>waiting for the promise to resolve...</p>\n{:then value}\n\t<!-- promise was fulfilled or not a Promise -->\n\t<p>The value is {value}</p>\n{:catch error}\n\t<!-- promise was rejected -->\n\t<p>Something went wrong: {error.message}</p>\n{/await}[!NOTE] During server-side rendering, only the pending branch will be rendered.\n\nIf the provided expression is not a `Promise` only the `:then` branch will be rendered, including during server-side rendering.\nThe catch block can be omitted if you don't need to render anything when the promise rejects (or no error is possible).{#await promise}\n\t<!-- promise is pending -->\n\t<p>waiting for the promise to resolve...</p>\n{:then value}\n\t<!-- promise was fulfilled -->\n\t<p>The value is {value}</p>\n{/await}If you don't care about the pending state, you can also omit the initial block.{#await promise then value}\n\t<p>The value is {value}</p>\n{/await}Similarly, if you only want to show the error state, you can omit the then block.{#await promise catch error}\n\t<p>The error is {error}</p>\n{/await}"
          },
          {
            "title": "{#snippet ...}",
            "content": "<!--- copy: false  --->\n{#snippet name()}...{/snippet}<!--- copy: false  --->\n{#snippet name(param1, param2, paramN)}...{/snippet}Snippets, and render tags, are a way to create reusable chunks of markup inside your components. Instead of writing duplicative code like this...{#each images as image}\n\t{#if image.href}\n\t\t<a href={image.href}>\n\t\t\t<figure>\n\t\t\t\t<img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n\t\t\t\t<figcaption>{image.caption}</figcaption>\n\t\t\t</figure>\n\t\t</a>\n\t{:else}\n\t\t<figure>\n\t\t\t<img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n\t\t\t<figcaption>{image.caption}</figcaption>\n\t\t</figure>\n\t{/if}\n{/each}...you can write this:{#snippet figure(image)}\n\t<figure>\n\t\t<img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n\t\t<figcaption>{image.caption}</figcaption>\n\t</figure>\n{/snippet}\n\n{#each images as image}\n\t{#if image.href}\n\t\t<a href={image.href}>\n\t\t\t{@render figure(image)}\n\t\t</a>\n\t{:else}\n\t\t{@render figure(image)}\n\t{/if}\n{/each}Like function declarations, snippets can have an arbitrary number of parameters, which can have default values, and you can destructure each parameter. You cannot use rest parameters however."
          },
          {
            "title": "{#snippet ...} > Snippet scope",
            "content": "Snippets can be declared anywhere inside your component. They can reference values declared outside themselves, for example in the <script> tag or in {#each ...} blocks (demo)...<script>\n\tlet { message = `it's great to see you!` } = $props();\n</script>\n\n{#snippet hello(name)}\n\t<p>hello {name}! {message}!</p>\n{/snippet}\n\n{@render hello('alice')}\n{@render hello('bob')}...and they are 'visible' to everything in the same lexical scope (i.e. siblings, and children of those siblings):<div>\n\t{#snippet x()}\n\t\t{#snippet y()}...{/snippet}\n\n\t\t<!-- this is fine -->\n\t\t{@render y()}\n\t{/snippet}\n\n\t<!-- this will error, as `y` is not in scope -->\n\t{@render y()}\n</div>\n\n<!-- this will also error, as `x` is not in scope -->\n{@render x()}Snippets can reference themselves and each other (demo):{#snippet blastoff()}\n\t<span>🚀</span>\n{/snippet}\n\n{#snippet countdown(n)}\n\t{#if n > 0}\n\t\t<span>{n}...</span>\n\t\t{@render countdown(n - 1)}\n\t{:else}\n\t\t{@render blastoff()}\n\t{/if}\n{/snippet}\n\n{@render countdown(10)}"
          },
          {
            "title": "{#snippet ...} > Passing snippets to components",
            "content": "Within the template, snippets are values just like any other. As such, they can be passed to components as props (demo):<script>\n\timport Table from './Table.svelte';\n\n\tconst fruits = [\n\t\t{ name: 'apples', qty: 5, price: 2 },\n\t\t{ name: 'bananas', qty: 10, price: 1 },\n\t\t{ name: 'cherries', qty: 20, price: 0.5 }\n\t];\n</script>\n\n{#snippet header()}\n\t<th>fruit</th>\n\t<th>qty</th>\n\t<th>price</th>\n\t<th>total</th>\n{/snippet}\n\n{#snippet row(d)}\n\t<td>{d.name}</td>\n\t<td>{d.qty}</td>\n\t<td>{d.price}</td>\n\t<td>{d.qty * d.price}</td>\n{/snippet}\n\n<Table data={fruits} {header} {row} />Think about it like passing content instead of data to a component. The concept is similar to slots in web components.As an authoring convenience, snippets declared directly inside a component implicitly become props on the component (demo):<!-- this is semantically the same as the above -->\n<Table data={fruits}>\n\t{#snippet header()}\n\t\t<th>fruit</th>\n\t\t<th>qty</th>\n\t\t<th>price</th>\n\t\t<th>total</th>\n\t{/snippet}\n\n\t{#snippet row(d)}\n\t\t<td>{d.name}</td>\n\t\t<td>{d.qty}</td>\n\t\t<td>{d.price}</td>\n\t\t<td>{d.qty * d.price}</td>\n\t{/snippet}\n</Table>Any content inside the component tags that is not a snippet declaration implicitly becomes part of the children snippet (demo):<!--- file: App.svelte --->\n<Button>click me<Button><!--- file: Button.svelte --->\n<script>\n\tlet { children } = $props();\n</script>\n\n<!-- result will be <button>click me</button> -->\n<button>{@render children()}</button>[!NOTE] Note that you cannot have a prop called `children` if you also have content inside the component — for this reason, you should avoid having props with that name\nYou can declare snippet props as being optional. You can either use optional chaining to not render anything if the snippet isn't set...<script>\n    let { children } = $props();\n</script>\n\n{@render children?.()}...or use an #if block to render fallback content:<script>\n    let { children } = $props();\n</script>\n\n{#if children}\n    {@render children()}\n{:else}\n    fallback content\n{/if}"
          },
          {
            "title": "{#snippet ...} > Typing snippets",
            "content": "Snippets implement the Snippet interface imported from 'svelte':<script lang=\"ts\">\n\timport type { Snippet } from 'svelte';\n\n\tinterface Props {\n\t\tdata: any[];\n\t\tchildren: Snippet;\n\t\trow: Snippet<[any]>;\n\t}\n\n\tlet { data, children, row }: Props = $props();\n</script>With this change, red squigglies will appear if you try and use the component without providing a data prop and a row snippet. Notice that the type argument provided to Snippet is a tuple, since snippets can have multiple parameters.We can tighten things up further by declaring a generic, so that data and row refer to the same type:<script lang=\"ts\" generics=\"T\">\n\timport type { Snippet } from 'svelte';\n\n\tlet {\n\t\tdata,\n\t\tchildren,\n\t\trow\n\t}: {\n\t\tdata: T[];\n\t\tchildren: Snippet;\n\t\trow: Snippet<[T]>;\n\t} = $props();\n</script>"
          },
          {
            "title": "{#snippet ...} > Programmatic snippets",
            "content": "Snippets can be created programmatically with the `createRawSnippet` API. This is intended for advanced use cases."
          },
          {
            "title": "{#snippet ...} > Snippets and slots",
            "content": "In Svelte 4, content can be passed to components using slots. Snippets are more powerful and flexible, and as such slots are deprecated in Svelte 5."
          },
          {
            "title": "{@render ...}",
            "content": "To render a snippet, use a {@render ...} tag.{#snippet sum(a, b)}\n\t<p>{a} + {b} = {a + b}</p>\n{/snippet}\n\n{@render sum(1, 2)}\n{@render sum(3, 4)}\n{@render sum(5, 6)}The expression can be an identifier like sum, or an arbitrary JavaScript expression:{@render (cool ? coolSnippet : lameSnippet)()}"
          },
          {
            "title": "{@render ...} > Optional snippets",
            "content": "If the snippet is potentially undefined — for example, because it's an incoming prop — then you can use optional chaining to only render it when it is defined:{@render children?.()}Alternatively, use an `{#if ...}` block with an :else clause to render fallback content:{#if children}\n\t{@render children()}\n{:else}\n\t<p>fallback content</p>\n{/if}"
          },
          {
            "title": "{@html ...}",
            "content": "To inject raw HTML into your component, use the {@html ...} tag:<article>\n\t{@html content}\n</article>[!NOTE] Make sure that you either escape the passed string or only populate it with values that are under your control in order to prevent [XSS attacks](https://owasp.org/www-community/attacks/xss/). Never render unsanitized content.\nThe expression should be valid standalone HTML — this will not work, because </div> is not valid HTML:{@html '<div>'}content{@html '</div>'}It also will not compile Svelte code."
          },
          {
            "title": "{@html ...} > Styling",
            "content": "Content rendered this way is 'invisible' to Svelte and as such will not receive scoped styles — in other words, this will not work, and the a and img styles will be regarded as unused:\n<article>\n\t{@html content}\n</article>\n\n<style>\n\tarticle {\n\t\ta { color: hotpink }\n\t\timg { width: 100% }\n\t}\n</style>Instead, use the :global modifier to target everything inside the <article>:\n<style>\n\tarticle +++:global+++ {\n\t\ta { color: hotpink }\n\t\timg { width: 100% }\n\t}\n</style>"
          },
          {
            "title": "{@const ...}",
            "content": "The {@const ...} tag defines a local constant.{#each boxes as box}\n\t{@const area = box.width * box.height}\n\t{box.width} * {box.height} = {area}\n{/each}{@const} is only allowed as an immediate child of a block — {#if ...}, {#each ...}, {#snippet ...} and so on — or a <Component />."
          },
          {
            "title": "{@debug ...}",
            "content": "The {@debug ...} tag offers an alternative to console.log(...). It logs the values of specific variables whenever they change, and pauses code execution if you have devtools open.<script>\n\tlet user = {\n\t\tfirstname: 'Ada',\n\t\tlastname: 'Lovelace'\n\t};\n</script>\n\n{@debug user}\n\n<h1>Hello {user.firstname}!</h1>{@debug ...} accepts a comma-separated list of variable names (not arbitrary expressions).<!-- Compiles -->\n{@debug user}\n{@debug user1, user2, user3}\n\n<!-- WON'T compile -->\n{@debug user.firstname}\n{@debug myArray[0]}\n{@debug !isReady}\n{@debug typeof user === 'object'}The {@debug} tag without any arguments will insert a debugger statement that gets triggered when any state changes, as opposed to the specified variables."
          },
          {
            "title": "bind:",
            "content": "Data ordinarily flows down, from parent to child. The bind: directive allows data to flow the other way, from child to parent.The general syntax is bind:property={expression}, where expression is an lvalue (i.e. a variable or an object property). When the expression is an identifier with the same name as the property, we can omit the expression — in other words these are equivalent:\n<input bind:value={value} />\n<input bind:value />Svelte creates an event listener that updates the bound value. If an element already has a listener for the same event, that listener will be fired before the bound value is updated.Most bindings are two-way, meaning that changes to the value will affect the element and vice versa. A few bindings are readonly, meaning that changing their value will have no effect on the element."
          },
          {
            "title": "bind: > <input bind:value>",
            "content": "A bind:value directive on an <input> element binds the input's value property:\n<script>\n\tlet message = $state('hello');\n</script>\n\n<input bind:value={message} />\n<p>{message}</p>In the case of a numeric input (type=&quot;number&quot; or type=&quot;range&quot;), the value will be coerced to a number (demo):<script>\n\tlet a = $state(1);\n\tlet b = $state(2);\n</script>\n\n<label>\n\t<input type=\"number\" bind:value={a} min=\"0\" max=\"10\" />\n\t<input type=\"range\" bind:value={a} min=\"0\" max=\"10\" />\n</label>\n\n<label>\n\t<input type=\"number\" bind:value={b} min=\"0\" max=\"10\" />\n\t<input type=\"range\" bind:value={b} min=\"0\" max=\"10\" />\n</label>\n\n<p>{a} + {b} = {a + b}</p>If the input is empty or invalid (in the case of type=&quot;number&quot;), the value is undefined."
          },
          {
            "title": "bind: > <input bind:checked>",
            "content": "Checkbox and radio inputs can be bound with bind:checked:<label>\n\t<input type=\"checkbox\" bind:checked={accepted} />\n\tAccept terms and conditions\n</label>"
          },
          {
            "title": "bind: > <input bind:group>",
            "content": "Inputs that work together can use bind:group.<script>\n\tlet tortilla = 'Plain';\n\n\t/** @type {Array<string>} */\n\tlet fillings = [];\n</script>\n\n<!-- grouped radio inputs are mutually exclusive -->\n<input type=\"radio\" bind:group={tortilla} value=\"Plain\" />\n<input type=\"radio\" bind:group={tortilla} value=\"Whole wheat\" />\n<input type=\"radio\" bind:group={tortilla} value=\"Spinach\" />\n\n<!-- grouped checkbox inputs populate an array -->\n<input type=\"checkbox\" bind:group={fillings} value=\"Rice\" />\n<input type=\"checkbox\" bind:group={fillings} value=\"Beans\" />\n<input type=\"checkbox\" bind:group={fillings} value=\"Cheese\" />\n<input type=\"checkbox\" bind:group={fillings} value=\"Guac (extra)\" />[!NOTE] `bind:group` only works if the inputs are in the same Svelte component."
          },
          {
            "title": "bind: > <input bind:files>",
            "content": "On <input> elements with type=&quot;file&quot;, you can use bind:files to get the `FileList` of selected files. When you want to update the files programmatically, you always need to use a FileList object. Currently FileList objects cannot be constructed directly, so you need to create a new `DataTransfer` object and get files from there.<script>\n\tlet files = $state();\n\n\tfunction clear() {\n\t\tfiles = new DataTransfer().files; // null or undefined does not work\n\t}\n</script>\n\n<label for=\"avatar\">Upload a picture:</label>\n<input accept=\"image/png, image/jpeg\" bind:files id=\"avatar\" name=\"avatar\" type=\"file\" />\n<button onclick={clear}>clear</button>FileList objects also cannot be modified, so if you want to e.g. delete a single file from the list, you need to create a new DataTransfer object and add the files you want to keep.[!NOTE] `DataTransfer` may not be available in server-side JS runtimes. Leaving the state that is bound to `files` uninitialized prevents potential errors if components are server-side rendered."
          },
          {
            "title": "bind: > <select bind:value>",
            "content": "A <select> value binding corresponds to the value property on the selected <option>, which can be any value (not just strings, as is normally the case in the DOM).<select bind:value={selected}>\n\t<option value={a}>a</option>\n\t<option value={b}>b</option>\n\t<option value={c}>c</option>\n</select>A <select multiple> element behaves similarly to a checkbox group. The bound variable is an array with an entry corresponding to the value property of each selected <option>.<select multiple bind:value={fillings}>\n\t<option value=\"Rice\">Rice</option>\n\t<option value=\"Beans\">Beans</option>\n\t<option value=\"Cheese\">Cheese</option>\n\t<option value=\"Guac (extra)\">Guac (extra)</option>\n</select>When the value of an <option> matches its text content, the attribute can be omitted.<select multiple bind:value={fillings}>\n\t<option>Rice</option>\n\t<option>Beans</option>\n\t<option>Cheese</option>\n\t<option>Guac (extra)</option>\n</select>"
          },
          {
            "title": "bind: > <audio>",
            "content": "<audio> elements have their own set of bindings — five two-way ones...undefined\n...and seven readonly ones:undefined\n<audio src={clip} bind:duration bind:currentTime bind:paused></audio>"
          },
          {
            "title": "bind: > <video>",
            "content": "<video> elements have all the same bindings as [#audio] elements, plus readonly `videoWidth` and `videoHeight` bindings."
          },
          {
            "title": "bind: > <img>",
            "content": "<img> elements have two readonly bindings:undefined"
          },
          {
            "title": "bind: > <details bind:open>",
            "content": "<details> elements support binding to the open property.<details bind:open={isOpen}>\n\t<summary>How do you comfort a JavaScript bug?</summary>\n\t<p>You console it.</p>\n</details>"
          },
          {
            "title": "bind: > Contenteditable bindings",
            "content": "Elements with the contenteditable attribute support the following bindings:undefined\n[!NOTE] There are [subtle differences between `innerText` and `textContent`](https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent#differences_from_innertext).\n\n\n<div contenteditable=\"true\" bind:innerHTML={html} />"
          },
          {
            "title": "bind: > Dimensions",
            "content": "All visible elements have the following readonly bindings, measured with a ResizeObserver:undefined\n<div bind:offsetWidth={width} bind:offsetHeight={height}>\n\t<Chart {width} {height} />\n</div>"
          },
          {
            "title": "bind: > bind:this",
            "content": "<!--- copy: false --->\nbind:this={dom_node}To get a reference to a DOM node, use bind:this. The value will be undefined until the component is mounted — in other words, you should read it inside an effect or an event handler, but not during component initialisation:<script>\n\t/** @type {HTMLCanvasElement} */\n\tlet canvas;\n\n\t$effect(() => {\n\t\tconst ctx = canvas.getContext('2d');\n\t\tdrawStuff(ctx);\n\t});\n</script>\n\n<canvas bind:this={canvas} />Components also support bind:this, allowing you to interact with component instances programmatically.<!--- file: App.svelte --->\n<ShoppingCart bind:this={cart} />\n\n<button onclick={() => cart.empty()}> Empty shopping cart </button><!--- file: ShoppingCart.svelte --->\n<script>\n\t// All instance exports are available on the instance object\n\texport function empty() {\n\t\t// ...\n\t}\n</script>"
          },
          {
            "title": "bind: > bind:property for components",
            "content": "bind:property={variable}You can bind to component props using the same syntax as for elements.<Keypad bind:value={pin} />While Svelte props are reactive without binding, that reactivity only flows downward into the component by default. Using bind:property allows changes to the property from within the component to flow back up out of the component.To mark a property as bindable, use the `$bindable` rune:<script>\n\tlet { readonlyProperty, bindableProperty = $bindable() } = $props();\n</script>Declaring a property as bindable means it can be used using bind:, not that it must be used using bind:.Bindable properties can have a fallback value:<script>\n\tlet { bindableProperty = $bindable('fallback value') } = $props();\n</script>This fallback value only applies when the property is not bound. When the property is bound and a fallback value is present, the parent is expected to provide a value other than undefined, else a runtime error is thrown. This prevents hard-to-reason-about situations where it's unclear which value should apply."
          },
          {
            "title": "use:",
            "content": "Actions are functions that are called when an element is mounted. They are added with the use: directive, and will typically use an $effect so that they can reset any state when the element is unmounted:<!--- file: App.svelte --->\n<script>\n\t/** @type {import('svelte/action').Action} */\n\tfunction myaction(node) {\n\t\t// the node has been mounted in the DOM\n\n\t\t$effect(() => {\n\t\t\t// setup goes here\n\n\t\t\treturn () => {\n\t\t\t\t// teardown goes here\n\t\t\t};\n\t\t});\n\t}\n</script>\n\n<div use:myaction>...</div>An action can be called with an argument:<!--- file: App.svelte --->\n<script>\n\t/** @type {import('svelte/action').Action} */\n\tfunction myaction(node, +++data+++) {\n\t\t// ...\n\t}\n</script>\n\n<div use:myaction={+++data+++}>...</div>The action is only called once (but not during server-side rendering) — it will not run again if the argument changes.[!LEGACY]\nPrior to the `$effect` rune, actions could return an object with `update` and `destroy` methods, where `update` would be called with the latest value of the argument if it changed. Using effects is preferred."
          },
          {
            "title": "use: > Typing",
            "content": "The Action interface receives three optional type arguments — a node type (which can be Element, if the action applies to everything), a parameter, and any custom event handlers created by the action.:<!--- file: App.svelte --->\n<script>\n\timport { on } from 'svelte/events';\n\n\t/**\n\t * @type {import('svelte/action').Action<\n\t * \tHTMLDivElement,\n\t * \tnull,\n\t * \t{\n\t * \t\tonswiperight: (e: CustomEvent) => void;\n\t * \t\tonswipeleft: (e: CustomEvent) => void;\n\t * \t\t// ...\n\t * }>}\n\t */\n\tfunction gestures(node) {\n\t\t$effect(() => {\n\t\t\t// ...\n\t\t\tnode.dispatchEvent(new CustomEvent('swipeleft'));\n\n\t\t\t// ...\n\t\t\tnode.dispatchEvent(new CustomEvent('swiperight'));\n\t\t});\n\t}\n</script>\n\n<div\n\tuse:gestures\n\tonswipeleft={next}\n\tonswiperight={prev}\n>...</div>"
          },
          {
            "title": "transition:",
            "content": "A transition is triggered by an element entering or leaving the DOM as a result of a state change.When a block (such as an {#if ...} block) is transitioning out, all elements inside it, including those that do not have their own transitions, are kept in the DOM until every transition in the block has been completed.The transition: directive indicates a bidirectional transition, which means it can be smoothly reversed while the transition is in progress.<script>\n\t+++import { fade } from 'svelte/transition';+++\n\n\tlet visible = $state(false);\n</script>\n\n<button onclick={() => visible = !visible}>toggle</button>\n\n{#if visible}\n\t<div +++transition:fade+++>fades in and out</div>\n{/if}"
          },
          {
            "title": "transition: > Built-in transitions",
            "content": "A selection of built-in transitions can be imported from the `svelte/transition` module."
          },
          {
            "title": "transition: > Local vs global",
            "content": "Transitions are local by default. Local transitions only play when the block they belong to is created or destroyed, not when parent blocks are created or destroyed.{#if x}\n\t{#if y}\n\t\t<p transition:fade>fades in and out only when y changes</p>\n\n\t\t<p transition:fade|global>fades in and out when x or y change</p>\n\t{/if}\n{/if}"
          },
          {
            "title": "transition: > Transition parameters",
            "content": "Transitions can have parameters.(The double {{curlies}} aren't a special syntax; this is an object literal inside an expression tag.){#if visible}\n\t<div transition:fade={{ duration: 2000 }}>fades in and out over two seconds</div>\n{/if}"
          },
          {
            "title": "transition: > Custom transition functions",
            "content": "/// copy: false\n \ntransition = (node: HTMLElement, params: any, options: { direction: 'in' | 'out' | 'both' }) => {\n\tdelay?: number,\n\tduration?: number,\n\teasing?: (t: number) => number,\n\tcss?: (t: number, u: number) => string,\n\ttick?: (t: number, u: number) => void\n}Transitions can use custom functions. If the returned object has a css function, Svelte will generate keyframes for a web animation.The t argument passed to css is a value between 0 and 1 after the easing function has been applied. In transitions run from 0 to 1, out transitions run from 1 to 0 — in other words, 1 is the element's natural state, as though no transition had been applied. The u argument is equal to 1 - t.The function is called repeatedly before the transition begins, with different t and u arguments.<!--- file: App.svelte --->\n<script>\n\timport { elasticOut } from 'svelte/easing';\n\n\t/** @type {boolean} */\n\texport let visible;\n\n\t/**\n\t * @param {HTMLElement} node\n\t * @param {{ delay?: number, duration?: number, easing?: (t: number) => number }} params\n\t */\n\tfunction whoosh(node, params) {\n\t\tconst existingTransform = getComputedStyle(node).transform.replace('none', '');\n\n\t\treturn {\n\t\t\tdelay: params.delay || 0,\n\t\t\tduration: params.duration || 400,\n\t\t\teasing: params.easing || elasticOut,\n\t\t\tcss: (t, u) => `transform: ${existingTransform} scale(${t})`\n\t\t};\n\t}\n</script>\n\n{#if visible}\n\t<div in:whoosh>whooshes in</div>\n{/if}A custom transition function can also return a tick function, which is called during the transition with the same t and u arguments.[!NOTE] If it's possible to use `css` instead of `tick`, do so — web animations can run off the main thread, preventing jank on slower devices.\n<!--- file: App.svelte --->\n<script>\n\texport let visible = false;\n\n\t/**\n\t * @param {HTMLElement} node\n\t * @param {{ speed?: number }} params\n\t */\n\tfunction typewriter(node, { speed = 1 }) {\n\t\tconst valid = node.childNodes.length === 1 && node.childNodes[0].nodeType === Node.TEXT_NODE;\n\n\t\tif (!valid) {\n\t\t\tthrow new Error(`This transition only works on elements with a single text node child`);\n\t\t}\n\n\t\tconst text = node.textContent;\n\t\tconst duration = text.length / (speed * 0.01);\n\n\t\treturn {\n\t\t\tduration,\n\t\t\ttick: (t) => {\n\t\t\t\tconst i = ~~(text.length * t);\n\t\t\t\tnode.textContent = text.slice(0, i);\n\t\t\t}\n\t\t};\n\t}\n</script>\n\n{#if visible}\n\t<p in:typewriter={{ speed: 1 }}>The quick brown fox jumps over the lazy dog</p>\n{/if}If a transition returns a function instead of a transition object, the function will be called in the next microtask. This allows multiple transitions to coordinate, making crossfade effects possible.Transition functions also receive a third argument, options, which contains information about the transition.Available values in the options object are:undefined"
          },
          {
            "title": "transition: > Transition events",
            "content": "An element with transitions will dispatch the following events in addition to any standard DOM events:undefined\n{#if visible}\n\t<p\n\t\ttransition:fly={{ y: 200, duration: 2000 }}\n\t\tonintrostart={() => (status = 'intro started')}\n\t\tonoutrostart={() => (status = 'outro started')}\n\t\tonintroend={() => (status = 'intro ended')}\n\t\tonoutroend={() => (status = 'outro ended')}\n\t>\n\t\tFlies in and out\n\t</p>\n{/if}"
          },
          {
            "title": "in: and out:",
            "content": "The in: and out: directives are identical to `transition:`, except that the resulting transitions are not bidirectional — an in transition will continue to 'play' alongside the out transition, rather than reversing, if the block is outroed while the transition is in progress. If an out transition is aborted, transitions will restart from scratch.{#if visible}\n\t<div in:fly out:fade>flies in, fades out</div>\n{/if}"
          },
          {
            "title": "animate:",
            "content": "An animation is triggered when the contents of a keyed each block are re-ordered. Animations do not run when an element is added or removed, only when the index of an existing data item within the each block changes. Animate directives must be on an element that is an immediate child of a keyed each block.Animations can be used with Svelte's built-in animation functions or custom animation functions.<!-- When `list` is reordered the animation will run-->\n{#each list as item, index (item)}\n\t<li animate:flip>{item}</li>\n{/each}"
          },
          {
            "title": "animate: > Animation Parameters",
            "content": "As with actions and transitions, animations can have parameters.(The double {{curlies}} aren't a special syntax; this is an object literal inside an expression tag.){#each list as item, index (item)}\n\t<li animate:flip={{ delay: 500 }}>{item}</li>\n{/each}"
          },
          {
            "title": "animate: > Custom animation functions",
            "content": "/// copy: false\n \nanimation = (node: HTMLElement, { from: DOMRect, to: DOMRect } , params: any) => {\n\tdelay?: number,\n\tduration?: number,\n\teasing?: (t: number) => number,\n\tcss?: (t: number, u: number) => string,\n\ttick?: (t: number, u: number) => void\n}Animations can use custom functions that provide the node, an animation object and any parameters as arguments. The animation parameter is an object containing from and to properties each containing a DOMRect describing the geometry of the element in its start and end positions. The from property is the DOMRect of the element in its starting position, and the to property is the DOMRect of the element in its final position after the list has been reordered and the DOM updated.If the returned object has a css method, Svelte will create a web animation that plays on the element.The t argument passed to css is a value that goes from 0 and 1 after the easing function has been applied. The u argument is equal to 1 - t.The function is called repeatedly before the animation begins, with different t and u arguments.\n<!--- file: App.svelte --->\n<script>\n\timport { cubicOut } from 'svelte/easing';\n\n\t/**\n\t * @param {HTMLElement} node\n\t * @param {{ from: DOMRect; to: DOMRect }} states\n\t * @param {any} params\n\t */\n\tfunction whizz(node, { from, to }, params) {\n\t\tconst dx = from.left - to.left;\n\t\tconst dy = from.top - to.top;\n\n\t\tconst d = Math.sqrt(dx * dx + dy * dy);\n\n\t\treturn {\n\t\t\tdelay: 0,\n\t\t\tduration: Math.sqrt(d) * 120,\n\t\t\teasing: cubicOut,\n\t\t\tcss: (t, u) => `transform: translate(${u * dx}px, ${u * dy}px) rotate(${t * 360}deg);`\n\t\t};\n\t}\n</script>\n\n{#each list as item, index (item)}\n\t<div animate:whizz>{item}</div>\n{/each}A custom animation function can also return a tick function, which is called during the animation with the same t and u arguments.[!NOTE] If it's possible to use `css` instead of `tick`, do so — web animations can run off the main thread, preventing jank on slower devices.\n<!--- file: App.svelte --->\n<script>\n\timport { cubicOut } from 'svelte/easing';\n\n\t/**\n\t * @param {HTMLElement} node\n\t * @param {{ from: DOMRect; to: DOMRect }} states\n\t * @param {any} params\n\t */\n\tfunction whizz(node, { from, to }, params) {\n\t\tconst dx = from.left - to.left;\n\t\tconst dy = from.top - to.top;\n\n\t\tconst d = Math.sqrt(dx * dx + dy * dy);\n\n\t\treturn {\n\t\t\tdelay: 0,\n\t\t\tduration: Math.sqrt(d) * 120,\n\t\t\teasing: cubicOut,\n\t\t\ttick: (t, u) => Object.assign(node.style, { color: t > 0.5 ? 'Pink' : 'Blue' })\n\t\t};\n\t}\n</script>\n\n{#each list as item, index (item)}\n\t<div animate:whizz>{item}</div>\n{/each}"
          },
          {
            "title": "class:",
            "content": "The class: directive is a convenient way to conditionally set classes on elements, as an alternative to using conditional expressions inside class attributes:<!-- These are equivalent -->\n<div class={isCool ? 'cool' : ''}>...</div>\n<div class:cool={isCool}>...</div>As with other directives, we can use a shorthand when the name of the class coincides with the value:<div class:cool>...</div>Multiple class: directives can be added to a single element:<div class:cool class:lame={!cool} class:potato>...</div>"
          },
          {
            "title": "style:",
            "content": "The style: directive provides a shorthand for setting multiple styles on an element.<!-- These are equivalent -->\n<div style:color=\"red\">...</div>\n<div style=\"color: red;\">...</div>The value can contain arbitrary expressions:<div style:color={myColor}>...</div>The shorthand form is allowed:<div style:color>...</div>Multiple styles can be set on a single element:<div style:color style:width=\"12rem\" style:background-color={darkMode ? 'black' : 'white'}>...</div>To mark a style as important, use the |important modifier:<div style:color|important=\"red\">...</div>When style: directives are combined with style attributes, the directives will take precedence:<div style=\"color: blue;\" style:color=\"red\">This will be red</div>"
          }
        ]
      },
      {
        "section": "Styling",
        "blocks": [
          {
            "title": "Scoped styles",
            "content": "Svelte components can include a <style> element containing CSS that belongs to the component. This CSS is scoped by default, meaning that styles will not apply to any elements on the page outside the component in question.This works by adding a class to affected elements, which is based on a hash of the component styles (e.g. svelte-123xyz).<style>\n\tp {\n\t\t/* this will only affect <p> elements in this component */\n\t\tcolor: burlywood;\n\t}\n</style>"
          },
          {
            "title": "Scoped styles > Specificity",
            "content": "Each scoped selector receives a specificity increase of 0-1-0, as a result of the scoping class (e.g. .svelte-123xyz) being added to the selector. This means that (for example) a p selector defined in a component will take precedence over a p selector defined in a global stylesheet, even if the global stylesheet is loaded later.In some cases, the scoping class must be added to a selector multiple times, but after the first occurrence it is added with :where(.svelte-xyz123) in order to not increase specificity further."
          },
          {
            "title": "Scoped styles > Scoped keyframes",
            "content": "If a component defines @keyframes, the name is scoped to the component using the same hashing approach. Any animation rules in the component will be similarly adjusted:<style>\n\t.bouncy {\n\t\tanimation: bounce 10s;\n\t}\n\n\t/* these keyframes are only accessible inside this component */\n\t@keyframes bounce {\n\t\t/* ... *.\n\t}\n</style>"
          },
          {
            "title": "Global styles > :global(...)",
            "content": "To apply styles to a single selector globally, use the :global(...) modifier:<style>\n\t:global(body) {\n\t\t/* applies to <body> */\n\t\tmargin: 0;\n\t}\n\n\tdiv :global(strong) {\n\t\t/* applies to all <strong> elements, in any component,\n\t\t   that are inside <div> elements belonging\n\t\t   to this component */\n\t\tcolor: goldenrod;\n\t}\n\n\tp:global(.big.red) {\n\t\t/* applies to all <p> elements belonging to this component\n\t\t   with `class=\"big red\"`, even if it is applied\n\t\t   programmatically (for example by a library) */\n\t}\n</style>If you want to make @keyframes that are accessible globally, you need to prepend your keyframe names with -global-.The -global- part will be removed when compiled, and the keyframe will then be referenced using just my-animation-name elsewhere in your code.<style>\n\t@keyframes -global-my-animation-name {\n\t\t/* code goes here */\n\t}\n</style>"
          },
          {
            "title": "Global styles > :global",
            "content": "To apply styles to a group of selectors globally, create a :global {...} block:<style>\n\t:global {\n\t\t/* applies to every <div> in your application */\n\t\tdiv { ... }\n\n\t\t/* applies to every <p> in your application */\n\t\tp { ... }\n\t}\n\n\t.a :global {\n\t\t/* applies to every `.b .c .d` element, in any component,\n\t\t   that is inside an `.a` element in this component */\n\t\t.b .c .d {...}\n\t}\n</style>[!NOTE] The second example above could also be written as an equivalent `.a :global .b .c .d` selector, where everything after the `:global` is unscoped, though the nested form is preferred."
          },
          {
            "title": "Custom properties",
            "content": "You can pass CSS custom properties — both static and dynamic — to components:<Slider\n\tbind:value\n\tmin={0}\n\tmax={100}\n\t--track-color=\"black\"\n\t--thumb-color=\"rgb({r} {g} {b})\"\n/>The above code essentially desugars to this:<svelte-css-wrapper style=\"display: contents; --track-color: black; --thumb-color: rgb({r} {g} {b})\">\n\t<Slider\n\t\tbind:value\n\t\tmin={0}\n\t\tmax={100}\n\t/>\n</svelte-css-wrapper>For an SVG element, it would use <g> instead:<g style=\"--track-color: black; --thumb-color: rgb({r} {g} {b})\">\n\t<Slider\n\t\tbind:value\n\t\tmin={0}\n\t\tmax={100}\n\t/>\n</g>Inside the component, we can read these custom properties (and provide fallback values) using `var(...)`:<style>\n\t.track {\n\t\tbackground: var(--track-color, #aaa);\n\t}\n\n\t.thumb {\n\t\tbackground: var(--thumb-color, blue);\n\t}\n</style>You don't have to specify the values directly on the component; as long as the custom properties are defined on a parent element, the component can use them. It's common to define custom properties on the :root element in a global stylesheet so that they apply to your entire application.[!NOTE] While the extra element will not affect layout, it _will_ affect any CSS selectors that (for example) use the `>` combinator to target an element directly inside the component's container."
          },
          {
            "title": "Nested <style> elements",
            "content": "There should only be 1 top-level <style> tag per component.However, it is possible to have a <style> tag nested inside other elements or logic blocks.In that case, the <style> tag will be inserted as-is into the DOM; no scoping or processing will be done on the <style> tag.<div>\n\t<style>\n\t\t/* this style tag will be inserted as-is */\n\t\tdiv {\n\t\t\t/* this will apply to all `<div>` elements in the DOM */\n\t\t\tcolor: red;\n\t\t}\n\t</style>\n</div>"
          }
        ]
      },
      {
        "section": "Special elements",
        "blocks": [
          {
            "title": "<svelte:window>",
            "content": "<svelte:window onevent={handler} /><svelte:window bind:prop={value} />The <svelte:window> element allows you to add event listeners to the window object without worrying about removing them when the component is destroyed, or checking for the existence of window when server-side rendering.This element may only appear at the top level of your component — it cannot be inside a block or element.<script>\n\tfunction handleKeydown(event) {\n\t\talert(`pressed the ${event.key} key`);\n\t}\n</script>\n\n<svelte:window onkeydown={handleKeydown} />You can also bind to the following properties:undefined\nAll except scrollX and scrollY are readonly.<svelte:window bind:scrollY={y} />[!NOTE] Note that the page will not be scrolled to the initial value to avoid accessibility issues. Only subsequent changes to the bound variable of `scrollX` and `scrollY` will cause scrolling. If you have a legitimate reason to scroll when the component is rendered, call `scrollTo()` in an `$effect`."
          },
          {
            "title": "<svelte:document>",
            "content": "<svelte:document onevent={handler} /><svelte:document bind:prop={value} />Similarly to <svelte:window>, this element allows you to add listeners to events on document, such as visibilitychange, which don't fire on window. It also lets you use actions on document.As with <svelte:window>, this element may only appear the top level of your component and must never be inside a block or element.<svelte:document onvisibilitychange={handleVisibilityChange} use:someAction />You can also bind to the following properties:undefined\nAll are readonly."
          },
          {
            "title": "<svelte:body>",
            "content": "<svelte:body onevent={handler} />Similarly to <svelte:window>, this element allows you to add listeners to events on document.body, such as mouseenter and mouseleave, which don't fire on window. It also lets you use actions on the <body> element.As with <svelte:window> and <svelte:document>, this element may only appear the top level of your component and must never be inside a block or element.<svelte:body onmouseenter={handleMouseenter} onmouseleave={handleMouseleave} use:someAction />"
          },
          {
            "title": "<svelte:head>",
            "content": "<svelte:head>...</svelte:head>This element makes it possible to insert elements into document.head. During server-side rendering, head content is exposed separately to the main body content.As with <svelte:window>, <svelte:document> and <svelte:body>, this element may only appear at the top level of your component and must never be inside a block or element.<svelte:head>\n\t<title>Hello world!</title>\n\t<meta name=\"description\" content=\"This is where the description goes for SEO\" />\n</svelte:head>"
          },
          {
            "title": "<svelte:element>",
            "content": "<svelte:element this={expression} />The <svelte:element> element lets you render an element that is unknown at author time, for example because it comes from a CMS. Any properties and event listeners present will be applied to the element.The only supported binding is bind:this, since Svelte's built-in bindings do not work with generic elements.If this has a nullish value, the element and its children will not be rendered.If this is the name of a void element (e.g., br) and <svelte:element> has child elements, a runtime error will be thrown in development mode:<script>\n\tlet tag = $state('hr');\n</script>\n\n<svelte:element this={tag}>\n\tThis text cannot appear inside an hr element\n</svelte:element>Svelte tries its best to infer the correct namespace from the element's surroundings, but it's not always possible. You can make it explicit with an xmlns attribute:<svelte:element this={tag} xmlns=\"http://www.w3.org/2000/svg\" />"
          },
          {
            "title": "<svelte:options>",
            "content": "<svelte:options option={value} />The <svelte:options> element provides a place to specify per-component compiler options, which are detailed in the compiler section. The possible options are:undefined\n<svelte:options customElement=\"my-custom-element\" />"
          }
        ]
      },
      {
        "section": "Runtime",
        "blocks": [
          {
            "title": "Stores",
            "content": "A store is an object that allows reactive access to a value via a simple store contract. The `svelte/store` module contains minimal store implementations which fulfil this contract.Any time you have a reference to a store, you can access its value inside a component by prefixing it with the $ character. This causes Svelte to declare the prefixed variable, subscribe to the store at component initialisation and unsubscribe when appropriate.Assignments to $-prefixed variables require that the variable be a writable store, and will result in a call to the store's .set method.Note that the store must be declared at the top level of the component — not inside an if block or a function, for example.Local variables (that do not represent store values) must not have a $ prefix.<script>\n\timport { writable } from 'svelte/store';\n\n\tconst count = writable(0);\n\tconsole.log($count); // logs 0\n\n\tcount.set(1);\n\tconsole.log($count); // logs 1\n\n\t$count = 2;\n\tconsole.log($count); // logs 2\n</script>"
          },
          {
            "title": "Stores > When to use stores",
            "content": "Prior to Svelte 5, stores were the go-to solution for creating cross-component reactive states or extracting logic. With runes, these use cases have greatly diminished.undefined\nStores are still a good solution when you have complex asynchronous data streams or it's important to have more manual control over updating values or listening to changes. If you're familiar with RxJs and want to reuse that knowledge, the $ also comes in handy for you."
          },
          {
            "title": "Stores > svelte/store",
            "content": "The svelte/store module contains a minimal store implementation which fulfil the store contract. It provides methods for creating stores that you can update from the outside, stores you can only update from the inside, and for combining and deriving stores."
          },
          {
            "title": "Stores > svelte/store > writable",
            "content": "Function that creates a store which has values that can be set from 'outside' components. It gets created as an object with additional set and update methods.set is a method that takes one argument which is the value to be set. The store value gets set to the value of the argument if the store value is not already equal to it.update is a method that takes one argument which is a callback. The callback takes the existing store value as its argument and returns the new value to be set to the store. \nimport { writable } from 'svelte/store';\n\nconst count = writable(0);\n\ncount.subscribe((value) => {\n\tconsole.log(value);\n}); // logs '0'\n\ncount.set(1); // logs '1'\n\ncount.update((n) => n + 1); // logs '2'If a function is passed as the second argument, it will be called when the number of subscribers goes from zero to one (but not from one to two, etc). That function will be passed a set function which changes the value of the store, and an update function which works like the update method on the store, taking a callback to calculate the store's new value from its old value. It must return a stop function that is called when the subscriber count goes from one to zero. \nimport { writable } from 'svelte/store';\n\nconst count = writable(0, () => {\n\tconsole.log('got a subscriber');\n\treturn () => console.log('no more subscribers');\n});\n\ncount.set(1); // does nothing\n\nconst unsubscribe = count.subscribe((value) => {\n\tconsole.log(value);\n}); // logs 'got a subscriber', then '1'\n\nunsubscribe(); // logs 'no more subscribers'Note that the value of a writable is lost when it is destroyed, for example when the page is refreshed. However, you can write your own logic to sync the value to for example the localStorage."
          },
          {
            "title": "Stores > svelte/store > readable",
            "content": "Creates a store whose value cannot be set from 'outside', the first argument is the store's initial value, and the second argument to readable is the same as the second argument to writable.import { readable } from 'svelte/store';\n\nconst time = readable(new Date(), (set) => {\n\tset(new Date());\n\n\tconst interval = setInterval(() => {\n\t\tset(new Date());\n\t}, 1000);\n\n\treturn () => clearInterval(interval);\n});\n\nconst ticktock = readable('tick', (set, update) => {\n\tconst interval = setInterval(() => {\n\t\tupdate((sound) => (sound === 'tick' ? 'tock' : 'tick'));\n\t}, 1000);\n\n\treturn () => clearInterval(interval);\n});"
          },
          {
            "title": "Stores > svelte/store > derived",
            "content": "Derives a store from one or more other stores. The callback runs initially when the first subscriber subscribes and then whenever the store dependencies change.In the simplest version, derived takes a single store, and the callback returns a derived value.import { derived } from 'svelte/store';\n\nconst doubled = derived(a, ($a) => $a * 2);The callback can set a value asynchronously by accepting a second argument, set, and an optional third argument, update, calling either or both of them when appropriate.In this case, you can also pass a third argument to derived — the initial value of the derived store before set or update is first called. If no initial value is specified, the store's initial value will be undefined.import { derived } from 'svelte/store';\n\nconst delayed = derived(\n\ta,\n\t($a, set) => {\n\t\tsetTimeout(() => set($a), 1000);\n\t},\n\t2000\n);\n\nconst delayedIncrement = derived(a, ($a, set, update) => {\n\tset($a);\n\tsetTimeout(() => update((x) => x + 1), 1000);\n\t// every time $a produces a value, this produces two\n\t// values, $a immediately and then $a + 1 a second later\n});If you return a function from the callback, it will be called when a) the callback runs again, or b) the last subscriber unsubscribes.import { derived } from 'svelte/store';\n\nconst tick = derived(\n\tfrequency,\n\t($frequency, set) => {\n\t\tconst interval = setInterval(() => {\n\t\t\tset(Date.now());\n\t\t}, 1000 / $frequency);\n\n\t\treturn () => {\n\t\t\tclearInterval(interval);\n\t\t};\n\t},\n\t2000\n);In both cases, an array of arguments can be passed as the first argument instead of a single store.import { derived } from 'svelte/store';\n\nconst summed = derived([a, b], ([$a, $b]) => $a + $b);\n\nconst delayed = derived([a, b], ([$a, $b], set) => {\n\tsetTimeout(() => set($a + $b), 1000);\n});"
          },
          {
            "title": "Stores > svelte/store > readonly",
            "content": "This simple helper function makes a store readonly. You can still subscribe to the changes from the original one using this new readable store.import { readonly, writable } from 'svelte/store';\n\nconst writableStore = writable(1);\nconst readableStore = readonly(writableStore);\n\nreadableStore.subscribe(console.log);\n\nwritableStore.set(2); // console: 2\n \nreadableStore.set(2); // ERROR"
          },
          {
            "title": "Stores > svelte/store > get",
            "content": "Generally, you should read the value of a store by subscribing to it and using the value as it changes over time. Occasionally, you may need to retrieve the value of a store to which you're not subscribed. get allows you to do so.[!NOTE] This works by creating a subscription, reading the value, then unsubscribing. It's therefore not recommended in hot code paths.\nimport { get } from 'svelte/store';\n\nconst value = get(store);"
          },
          {
            "title": "Stores > Store contract",
            "content": "store = { subscribe: (subscription: (value: any) => void) => (() => void), set?: (value: any) => void }You can create your own stores without relying on `svelte/store`, by implementing the store contract:undefined\nFor interoperability with RxJS Observables, the .subscribe method is also allowed to return an object with an .unsubscribe method, rather than return the unsubscription function directly. Note however that unless .subscribe synchronously calls the subscription (which is not required by the Observable spec), Svelte will see the value of the store as undefined until it does."
          },
          {
            "title": "Context",
            "content": "Most state is component-level state that lives as long as its component lives. There's also section-wide or app-wide state however, which also needs to be handled somehow.The easiest way to do that is to create global state and just import that. \nexport const myGlobalState = $state({\n\tuser: {\n\t\t/* ... */\n\t}\n\t/* ... */\n});<!--- file: App.svelte --->\n<script>\n\timport { myGlobalState } from './state.svelte';\n\t// ...\n</script>This has a few drawbacks though:undefined\nTo solve these drawbacks, Svelte provides a few context primitives which alleviate these problems."
          },
          {
            "title": "Context > Setting and getting context",
            "content": "To associate an arbitrary object with the current component, use setContext.<script>\n\timport { setContext } from 'svelte';\n\n\tsetContext('key', value);\n</script>The context is then available to children of the component (including slotted content) with getContext.<script>\n\timport { getContext } from 'svelte';\n\n\tconst value = getContext('key');\n</script>setContext and getContext solve the above problems:undefined\n[!NOTE] `setContext`/`getContext` must be called during component initialisation.\nContext is not inherently reactive. If you need reactive values in context then you can pass a $state object into context, whose properties will be reactive.<!--- file: Parent.svelte --->\n<script>\n\timport { setContext } from 'svelte';\n\n\tlet value = $state({ count: 0 });\n\tsetContext('counter', value);\n</script>\n\n<button onclick={() => value.count++}>increment</button><!--- file: Child.svelte --->\n<script>\n\timport { setContext } from 'svelte';\n\n\tconst value = setContext('counter');\n</script>\n\n<p>Count is {value.count}</p>To check whether a given key has been set in the context of a parent component, use hasContext.<script>\n\timport { hasContext } from 'svelte';\n\n\tif (hasContext('key')) {\n\t\t// do something\n\t}\n</script>You can also retrieve the whole context map that belongs to the closest parent component using getAllContexts. This is useful, for example, if you programmatically create a component and want to pass the existing context to it.<script>\n\timport { getAllContexts } from 'svelte';\n\n\tconst contexts = getAllContexts();\n</script>"
          },
          {
            "title": "Context > Encapsulating context interactions",
            "content": "The above methods are very unopinionated about how to use them. When your app grows in scale, it's worthwhile to encapsulate setting and getting the context into functions and properly type them. \nimport { getContext, setContext } from 'svelte';\n\nlet userKey = Symbol('user');\n\nexport function setUserContext(user: User) {\n\tsetContext(userKey, user);\n}\n\nexport function getUserContext(): User {\n\treturn getContext(userKey) as User;\n}"
          },
          {
            "title": "Lifecycle hooks",
            "content": "In Svelte 5, the component lifecycle consists of only two parts: Its creation and its destruction. Everything in-between - when certain state is updated - is not related to the component as a whole, only the parts that need to react to the state change are notified. This is because under the hood the smallest unit of change is actually not a component, it's the (render) effects that the component sets up upon component initialization. Consequently, there's no such thing as a &quot;before update&quot;/&quot;after update&quot; hook."
          },
          {
            "title": "Lifecycle hooks > onMount",
            "content": "The onMount function schedules a callback to run as soon as the component has been mounted to the DOM. It must be called during the component's initialisation (but doesn't need to live inside the component; it can be called from an external module).onMount does not run inside a component that is rendered on the server.<script>\n\timport { onMount } from 'svelte';\n\n\tonMount(() => {\n\t\tconsole.log('the component has mounted');\n\t});\n</script>If a function is returned from onMount, it will be called when the component is unmounted.<script>\n\timport { onMount } from 'svelte';\n\n\tonMount(() => {\n\t\tconst interval = setInterval(() => {\n\t\t\tconsole.log('beep');\n\t\t}, 1000);\n\n\t\treturn () => clearInterval(interval);\n\t});\n</script>[!NOTE] This behaviour will only work when the function passed to `onMount` _synchronously_ returns a value. `async` functions always return a `Promise`, and as such cannot _synchronously_ return a function."
          },
          {
            "title": "Lifecycle hooks > onDestroy",
            "content": "Schedules a callback to run immediately before the component is unmounted.Out of onMount, beforeUpdate, afterUpdate and onDestroy, this is the\nonly one that runs inside a server-side component.\nfunction onDestroy(fn: () => any): void;\nSchedules a callback to run immediately before the component is unmounted.Out of onMount, beforeUpdate, afterUpdate and onDestroy, this is the only one that runs inside a server-side component.<script>\n\timport { onDestroy } from 'svelte';\n\n\tonDestroy(() => {\n\t\tconsole.log('the component is being destroyed');\n\t});\n</script>"
          },
          {
            "title": "Lifecycle hooks > tick",
            "content": "While there's no &quot;after update&quot; hook, you can use tick to ensure that the UI is updated before continuing. tick returns a promise that resolves once any pending state changes have been applied, or in the next microtask if there are none.<script>\n\timport { beforeUpdate, tick } from 'svelte';\n\n\tbeforeUpdate(async () => {\n\t\tconsole.log('the component is about to update');\n\t\tawait tick();\n\t\tconsole.log('the component just updated');\n\t});\n</script>"
          },
          {
            "title": "Lifecycle hooks > Deprecated: beforeUpdate / afterUpdate",
            "content": "Svelte 4 contained hooks that ran before and after the component as a whole was updated. For backwards compatibility, these hooks were shimmed in Svelte 5 but not available inside components that use runes.<script>\n\timport { beforeUpdate, afterUpdate } from 'svelte';\n\n\tbeforeUpdate(() => {\n\t\tconsole.log('the component is about to update');\n\t});\n\n\tafterUpdate(() => {\n\t\tconsole.log('the component just updated');\n\t});\n</script>Instead of beforeUpdate use $effect.pre and instead of afterUpdate use $effect instead - these runes offer more granular control and only react to the changes you're actually interested in."
          },
          {
            "title": "Lifecycle hooks > Deprecated: beforeUpdate / afterUpdate > Chat window example",
            "content": "To implement a chat window that autoscrolls to the bottom when new messages appear (but only if you were already scrolled to the bottom), we need to measure the DOM before we update it.In Svelte 4, we do this with beforeUpdate, but this is a flawed approach — it fires before every update, whether it's relevant or not. In the example below, we need to introduce checks like updatingMessages to make sure we don't mess with the scroll position when someone toggles dark mode.With runes, we can use $effect.pre, which behaves the same as $effect but runs before the DOM is updated. As long as we explicitly reference messages inside the effect body, it will run whenever messages changes, but not when theme changes.beforeUpdate, and its equally troublesome counterpart afterUpdate, are therefore deprecated in Svelte 5.undefined\n\n<script>\n\timport { ---beforeUpdate, afterUpdate,--- tick } from 'svelte';\n\n\t---let updatingMessages = false;---\n\tlet theme = +++$state('dark')+++;\n\tlet messages = +++$state([])+++;\n\n\tlet viewport;\n\n\t---beforeUpdate(() => {---\n\t+++$effect.pre(() => {+++\n\t\t---if (!updatingMessages) return;---\n\t\t+++messages;+++\n\t\tconst autoscroll = viewport && viewport.offsetHeight + viewport.scrollTop > viewport.scrollHeight - 50;\n\n\t\tif (autoscroll) {\n\t\t\ttick().then(() => {\n\t\t\t\tviewport.scrollTo(0, viewport.scrollHeight);\n\t\t\t});\n\t\t}\n\n\t\t---updatingMessages = false;---\n\t});\n\n\tfunction handleKeydown(event) {\n\t\tif (event.key === 'Enter') {\n\t\t\tconst text = event.target.value;\n\t\t\tif (!text) return;\n\n\t\t\t---updatingMessages = true;---\n\t\t\tmessages = [...messages, text];\n\t\t\tevent.target.value = '';\n\t\t}\n\t}\n\n\tfunction toggle() {\n\t\ttoggleValue = !toggleValue;\n\t}\n</script>\n\n<div class:dark={theme === 'dark'}>\n\t<div bind:this={viewport}>\n\t\t{#each messages as message}\n\t\t\t<p>{message}</p>\n\t\t{/each}\n\t</div>\n\n\t<input +++onkeydown+++={handleKeydown} />\n\n\t<button +++onclick+++={toggle}> Toggle dark mode </button>\n</div>"
          },
          {
            "title": "Imperative component API",
            "content": "Every Svelte application starts by imperatively creating a root component. On the client this component is mounted to a specific element. On the server, you want to get back a string of HTML instead which you can render. The following functions help you achieve those tasks."
          },
          {
            "title": "Imperative component API > mount",
            "content": "Instantiates a component and mounts it to the given target: \nimport { mount } from 'svelte';\nimport App from './App.svelte';\n\nconst app = mount(App, {\n\ttarget: document.querySelector('#app'),\n\tprops: { some: 'property' }\n});You can mount multiple components per page, and you can also mount from within your application, for example when creating a tooltip component and attaching it to the hovered element.Note that unlike calling new App(...) in Svelte 4, things like effects (including onMount callbacks, and action functions) will not run during mount. If you need to force pending effects to run (in the context of a test, for example) you can do so with flushSync()."
          },
          {
            "title": "Imperative component API > unmount",
            "content": "Unmounts a component created with `mount` or `hydrate`: \nimport { mount, unmount } from 'svelte';\nimport App from './App.svelte';\n\nconst app = mount(App, {...});\n\n// later\nunmount(app);"
          },
          {
            "title": "Imperative component API > render",
            "content": "Only available on the server and when compiling with the server option. Takes a component and returns an object with body and head properties on it, which you can use to populate the HTML when server-rendering your app: \nimport { render } from 'svelte/server';\nimport App from './App.svelte';\n\nconst result = render(App, {\n\tprops: { some: 'property' }\n});\nresult.body; // HTML for somewhere in this <body> tag\nresult.head; // HTML for somewhere in this <head> tag"
          },
          {
            "title": "Imperative component API > hydrate",
            "content": "Like mount, but will reuse up any HTML rendered by Svelte's SSR output (from the `render` function) inside the target and make it interactive: \nimport { hydrate } from 'svelte';\nimport App from './App.svelte';\n\nconst app = hydrate(App, {\n\ttarget: document.querySelector('#app'),\n\tprops: { some: 'property' }\n});As with mount, effects will not run during hydrate — use flushSync() immediately afterwards if you need them to."
          }
        ]
      }
    ]
  }
]